// AUTOGENERATED BY storj.io/dbx
// DO NOT EDIT.

package exhaustive

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"cloud.google.com/go/spanner"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	_ "github.com/googleapis/go-sql-spanner"
	"github.com/jackc/pgx/v5/pgconn"
	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/mattn/go-sqlite3"
)

// Prevent conditional imports from causing build failures.
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...any)

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...any) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func (e *Error) Unwrap() error {
	return e.Err
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	var e *Error
	if errors.As(err, &e) {
		return wrapErr(e)
	}
	e = &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	case "pgx":
		sql_db, err = openpgx(source)
	case "pgxcockroach":
		sql_db, err = openpgxcockroach(source)
	case "spanner":
		sql_db, err = openspanner(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			_ = sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	case "pgx":
		db.dbMethods = newpgx(db)
	case "pgxcockroach":
		db.dbMethods = newpgxcockroach(db)
	case "spanner":
		db.dbMethods = newspanner(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
	txn     bool
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...any) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() []string {
	return []string{

		`CREATE TABLE as (
	pk INTEGER NOT NULL,
	ctime TIMESTAMP NOT NULL,
	mtime TIMESTAMP NOT NULL,
	id TEXT NOT NULL,
	name TEXT NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( name )
)`,

		`CREATE TABLE bs (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	data TEXT NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE foos (
	id INTEGER NOT NULL,
	int INTEGER NOT NULL,
	int64 INTEGER NOT NULL,
	uint INTEGER NOT NULL,
	uint64 INTEGER NOT NULL,
	float REAL NOT NULL,
	float64 REAL NOT NULL,
	string TEXT NOT NULL,
	blob BLOB NOT NULL,
	timestamp TIMESTAMP NOT NULL,
	utimestamp TIMESTAMP NOT NULL,
	bool INTEGER NOT NULL,
	date DATE NOT NULL,
	json TEXT NOT NULL,
	null_int INTEGER,
	null_int64 INTEGER,
	null_uint INTEGER,
	null_uint64 INTEGER,
	null_float REAL,
	null_float64 REAL,
	null_string TEXT,
	null_blob BLOB,
	null_timestamp TIMESTAMP,
	null_utimestamp TIMESTAMP,
	null_bool INTEGER,
	null_date DATE,
	null_json TEXT,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE a_bs (
	b_pk INTEGER NOT NULL REFERENCES bs( pk ) ON DELETE CASCADE,
	a_pk INTEGER NOT NULL REFERENCES as( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( b_pk, a_pk )
)`,

		`CREATE TABLE cs (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	b_pk INTEGER NOT NULL REFERENCES bs( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE es (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	a_id TEXT NOT NULL REFERENCES as( id ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE ds (
	pk INTEGER NOT NULL,
	id TEXT NOT NULL,
	alias TEXT,
	date TIMESTAMP NOT NULL,
	e_id TEXT NOT NULL REFERENCES es( id ),
	a_id TEXT NOT NULL REFERENCES as( id ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( a_id, alias )
)`,

		`CREATE UNIQUE INDEX as_ctime_mtime_unique_index ON as ( ctime, mtime )`,
	}
}

func (obj *sqlite3DB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS ds`,

		`DROP TABLE IF EXISTS es`,

		`DROP TABLE IF EXISTS cs`,

		`DROP TABLE IF EXISTS a_bs`,

		`DROP TABLE IF EXISTS foos`,

		`DROP TABLE IF EXISTS bs`,

		`DROP TABLE IF EXISTS as`,
	}
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pgxImpl struct {
	db      *DB
	dialect __sqlbundle_pgx
	driver  driver
	txn     bool
}

func (obj *pgxImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *pgxImpl) logStmt(stmt string, args ...any) {
	pgxLogStmt(stmt, args...)
}

func (obj *pgxImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type pgxDB struct {
	db *DB
	*pgxImpl
}

func newpgx(db *DB) *pgxDB {
	return &pgxDB{
		db: db,
		pgxImpl: &pgxImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *pgxDB) Schema() []string {
	return []string{

		`CREATE TABLE as (
	pk bigserial NOT NULL,
	ctime timestamp with time zone NOT NULL,
	mtime timestamp with time zone NOT NULL,
	id text NOT NULL,
	name text NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( name )
)`,

		`CREATE TABLE bs (
	pk bigserial NOT NULL,
	id text NOT NULL,
	data text NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE foos (
	id bigserial NOT NULL,
	int integer NOT NULL,
	int64 bigint NOT NULL,
	uint integer NOT NULL,
	uint64 bigint NOT NULL,
	float real NOT NULL,
	float64 double precision NOT NULL,
	string text NOT NULL,
	blob bytea NOT NULL,
	timestamp timestamp with time zone NOT NULL,
	utimestamp timestamp NOT NULL,
	bool boolean NOT NULL,
	date date NOT NULL,
	json jsonb NOT NULL,
	null_int integer,
	null_int64 bigint,
	null_uint integer,
	null_uint64 bigint,
	null_float real,
	null_float64 double precision,
	null_string text,
	null_blob bytea,
	null_timestamp timestamp with time zone,
	null_utimestamp timestamp,
	null_bool boolean,
	null_date date,
	null_json jsonb,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE a_bs (
	b_pk bigint NOT NULL REFERENCES bs( pk ) ON DELETE CASCADE,
	a_pk bigint NOT NULL REFERENCES as( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( b_pk, a_pk )
)`,

		`CREATE TABLE cs (
	pk bigserial NOT NULL,
	id text NOT NULL,
	b_pk bigint NOT NULL REFERENCES bs( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE es (
	pk bigserial NOT NULL,
	id text NOT NULL,
	a_id text NOT NULL REFERENCES as( id ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE ds (
	pk bigserial NOT NULL,
	id text NOT NULL,
	alias text,
	date timestamp with time zone NOT NULL,
	e_id text NOT NULL REFERENCES es( id ),
	a_id text NOT NULL REFERENCES as( id ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( a_id, alias )
)`,

		`CREATE UNIQUE INDEX as_ctime_mtime_unique_index ON as ( ctime, mtime )`,
	}
}

func (obj *pgxDB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS ds`,

		`DROP TABLE IF EXISTS es`,

		`DROP TABLE IF EXISTS cs`,

		`DROP TABLE IF EXISTS a_bs`,

		`DROP TABLE IF EXISTS foos`,

		`DROP TABLE IF EXISTS bs`,

		`DROP TABLE IF EXISTS as`,
	}
}

func (obj *pgxDB) wrapTx(tx *sql.Tx) txMethods {
	return &pgxTx{
		dialectTx: dialectTx{tx: tx},
		pgxImpl: &pgxImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type pgxTx struct {
	dialectTx
	*pgxImpl
}

func pgxLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pgxcockroachImpl struct {
	db      *DB
	dialect __sqlbundle_pgxcockroach
	driver  driver
	txn     bool
}

func (obj *pgxcockroachImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *pgxcockroachImpl) logStmt(stmt string, args ...any) {
	pgxcockroachLogStmt(stmt, args...)
}

func (obj *pgxcockroachImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type pgxcockroachDB struct {
	db *DB
	*pgxcockroachImpl
}

func newpgxcockroach(db *DB) *pgxcockroachDB {
	return &pgxcockroachDB{
		db: db,
		pgxcockroachImpl: &pgxcockroachImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *pgxcockroachDB) Schema() []string {
	return []string{

		`CREATE TABLE as (
	pk bigserial NOT NULL,
	ctime timestamp with time zone NOT NULL,
	mtime timestamp with time zone NOT NULL,
	id text NOT NULL,
	name text NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( name )
)`,

		`CREATE TABLE bs (
	pk bigserial NOT NULL,
	id text NOT NULL,
	data text NOT NULL,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE foos (
	id bigserial NOT NULL,
	int integer NOT NULL,
	int64 bigint NOT NULL,
	uint integer NOT NULL,
	uint64 bigint NOT NULL,
	float real NOT NULL,
	float64 double precision NOT NULL,
	string text NOT NULL,
	blob bytea NOT NULL,
	timestamp timestamp with time zone NOT NULL,
	utimestamp timestamp NOT NULL,
	bool boolean NOT NULL,
	date date NOT NULL,
	json jsonb NOT NULL,
	null_int integer,
	null_int64 bigint,
	null_uint integer,
	null_uint64 bigint,
	null_float real,
	null_float64 double precision,
	null_string text,
	null_blob bytea,
	null_timestamp timestamp with time zone,
	null_utimestamp timestamp,
	null_bool boolean,
	null_date date,
	null_json jsonb,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE a_bs (
	b_pk bigint NOT NULL REFERENCES bs( pk ) ON DELETE CASCADE,
	a_pk bigint NOT NULL REFERENCES as( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( b_pk, a_pk )
)`,

		`CREATE TABLE cs (
	pk bigserial NOT NULL,
	id text NOT NULL,
	b_pk bigint NOT NULL REFERENCES bs( pk ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE es (
	pk bigserial NOT NULL,
	id text NOT NULL,
	a_id text NOT NULL REFERENCES as( id ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id )
)`,

		`CREATE TABLE ds (
	pk bigserial NOT NULL,
	id text NOT NULL,
	alias text,
	date timestamp with time zone NOT NULL,
	e_id text NOT NULL REFERENCES es( id ),
	a_id text NOT NULL REFERENCES as( id ) ON DELETE CASCADE,
	PRIMARY KEY ( pk ),
	UNIQUE ( id ),
	UNIQUE ( a_id, alias )
)`,

		`CREATE UNIQUE INDEX as_ctime_mtime_unique_index ON as ( ctime, mtime )`,
	}
}

func (obj *pgxcockroachDB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS ds`,

		`DROP TABLE IF EXISTS es`,

		`DROP TABLE IF EXISTS cs`,

		`DROP TABLE IF EXISTS a_bs`,

		`DROP TABLE IF EXISTS foos`,

		`DROP TABLE IF EXISTS bs`,

		`DROP TABLE IF EXISTS as`,
	}
}

func (obj *pgxcockroachDB) wrapTx(tx *sql.Tx) txMethods {
	return &pgxcockroachTx{
		dialectTx: dialectTx{tx: tx},
		pgxcockroachImpl: &pgxcockroachImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type pgxcockroachTx struct {
	dialectTx
	*pgxcockroachImpl
}

func pgxcockroachLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type spannerImpl struct {
	db      *DB
	dialect __sqlbundle_spanner
	driver  driver
	txn     bool
}

func (obj *spannerImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *spannerImpl) logStmt(stmt string, args ...any) {
	spannerLogStmt(stmt, args...)
}

func (obj *spannerImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type spannerDB struct {
	db *DB
	*spannerImpl
}

func newspanner(db *DB) *spannerDB {
	return &spannerDB{
		db: db,
		spannerImpl: &spannerImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *spannerDB) Schema() []string {
	return []string{

		`CREATE SEQUENCE as_pk OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE as (
	pk INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE as_pk)),
	ctime TIMESTAMP NOT NULL,
	mtime TIMESTAMP NOT NULL,
	id STRING(MAX) NOT NULL,
	name STRING(MAX) NOT NULL
) PRIMARY KEY ( pk )`,

		`CREATE UNIQUE INDEX index_as_id ON as ( id )`,

		`CREATE UNIQUE INDEX index_as_name ON as ( name )`,

		`CREATE SEQUENCE bs_pk OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE bs (
	pk INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE bs_pk)),
	id STRING(MAX) NOT NULL,
	data STRING(MAX) NOT NULL
) PRIMARY KEY ( pk )`,

		`CREATE UNIQUE INDEX index_bs_id ON bs ( id )`,

		`CREATE SEQUENCE foos_id OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE foos (
	id INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE foos_id)),
	int INT64 NOT NULL,
	int64 INT64 NOT NULL,
	uint INT64 NOT NULL,
	uint64 INT64 NOT NULL,
	float FLOAT32 NOT NULL,
	float64 FLOAT64 NOT NULL,
	string STRING(MAX) NOT NULL,
	blob BYTES(MAX) NOT NULL,
	timestamp TIMESTAMP NOT NULL,
	utimestamp TIMESTAMP NOT NULL,
	bool BOOL NOT NULL,
	date DATE NOT NULL,
	json JSON NOT NULL,
	null_int INT64,
	null_int64 INT64,
	null_uint INT64,
	null_uint64 INT64,
	null_float FLOAT32,
	null_float64 FLOAT64,
	null_string STRING(MAX),
	null_blob BYTES(MAX),
	null_timestamp TIMESTAMP,
	null_utimestamp TIMESTAMP,
	null_bool BOOL,
	null_date DATE,
	null_json JSON
) PRIMARY KEY ( id )`,

		`CREATE TABLE a_bs (
	b_pk INT64 NOT NULL,
	a_pk INT64 NOT NULL,
	CONSTRAINT a_bs_b_pk_fkey FOREIGN KEY (b_pk) REFERENCES bs (pk) ON DELETE CASCADE ,
	CONSTRAINT a_bs_a_pk_fkey FOREIGN KEY (a_pk) REFERENCES as (pk) ON DELETE CASCADE 
) PRIMARY KEY ( b_pk, a_pk )`,

		`CREATE SEQUENCE cs_pk OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE cs (
	pk INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE cs_pk)),
	id STRING(MAX) NOT NULL,
	b_pk INT64 NOT NULL,
	CONSTRAINT cs_b_pk_fkey FOREIGN KEY (b_pk) REFERENCES bs (pk) ON DELETE CASCADE 
) PRIMARY KEY ( pk )`,

		`CREATE UNIQUE INDEX index_cs_id ON cs ( id )`,

		`CREATE SEQUENCE es_pk OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE es (
	pk INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE es_pk)),
	id STRING(MAX) NOT NULL,
	a_id STRING(MAX) NOT NULL,
	CONSTRAINT es_a_id_fkey FOREIGN KEY (a_id) REFERENCES as (id) ON DELETE CASCADE 
) PRIMARY KEY ( pk )`,

		`CREATE UNIQUE INDEX index_es_id ON es ( id )`,

		`CREATE SEQUENCE ds_pk OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE ds (
	pk INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE ds_pk)),
	id STRING(MAX) NOT NULL,
	alias STRING(MAX),
	date TIMESTAMP NOT NULL,
	e_id STRING(MAX) NOT NULL,
	a_id STRING(MAX) NOT NULL,
	CONSTRAINT ds_e_id_fkey FOREIGN KEY (e_id) REFERENCES es (id),
	CONSTRAINT ds_a_id_fkey FOREIGN KEY (a_id) REFERENCES as (id) ON DELETE CASCADE 
) PRIMARY KEY ( pk )`,

		`CREATE UNIQUE INDEX index_ds_id ON ds ( id )`,

		`CREATE UNIQUE INDEX index_ds_a_id_alias ON ds ( a_id, alias )`,

		`CREATE UNIQUE INDEX as_ctime_mtime_unique_index ON as ( ctime, mtime )`,
	}
}

func (obj *spannerDB) DropSchema() []string {
	return []string{

		`ALTER TABLE ds DROP CONSTRAINT ds_e_id_fkey`,

		`ALTER TABLE ds DROP CONSTRAINT ds_a_id_fkey`,

		`DROP INDEX IF EXISTS index_ds_id`,

		`DROP INDEX IF EXISTS index_ds_a_id_alias`,

		`ALTER TABLE es DROP CONSTRAINT es_a_id_fkey`,

		`DROP INDEX IF EXISTS index_es_id`,

		`ALTER TABLE cs DROP CONSTRAINT cs_b_pk_fkey`,

		`DROP INDEX IF EXISTS index_cs_id`,

		`ALTER TABLE a_bs DROP CONSTRAINT a_bs_b_pk_fkey`,

		`ALTER TABLE a_bs DROP CONSTRAINT a_bs_a_pk_fkey`,

		`DROP INDEX IF EXISTS index_bs_id`,

		`DROP INDEX IF EXISTS index_as_id`,

		`DROP INDEX IF EXISTS index_as_name`,

		`DROP INDEX IF EXISTS as_ctime_mtime_unique_index`,

		`ALTER TABLE  ds ALTER pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS ds_pk`,

		`DROP TABLE IF EXISTS ds`,

		`ALTER TABLE  es ALTER pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS es_pk`,

		`DROP TABLE IF EXISTS es`,

		`ALTER TABLE  cs ALTER pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS cs_pk`,

		`DROP TABLE IF EXISTS cs`,

		`ALTER TABLE  a_bs ALTER b_pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS a_bs_b_pk`,

		`ALTER TABLE  a_bs ALTER a_pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS a_bs_a_pk`,

		`DROP TABLE IF EXISTS a_bs`,

		`ALTER TABLE  foos ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS foos_id`,

		`DROP TABLE IF EXISTS foos`,

		`ALTER TABLE  bs ALTER pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS bs_pk`,

		`DROP TABLE IF EXISTS bs`,

		`ALTER TABLE  as ALTER pk SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS as_pk`,

		`DROP TABLE IF EXISTS as`,
	}
}

func (obj *spannerDB) wrapTx(tx *sql.Tx) txMethods {
	return &spannerTx{
		dialectTx: dialectTx{tx: tx},
		spannerImpl: &spannerImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type spannerTx struct {
	dialectTx
	*spannerImpl
}

func spannerLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []any

func (p pretty) Format(f fmt.State, c rune) {
	_, _ = fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			_, _ = fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				_, _ = fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			_, _ = fmt.Fprintf(f, "%q", v)
		case time.Time:
			_, _ = fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					_, _ = fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			_, _ = fmt.Fprintf(f, "%q", v)
		default:
			_, _ = fmt.Fprintf(f, "%v", v)
		}
	}
	_, _ = fmt.Fprint(f, "]")
}

type A struct {
	Pk    int64
	Ctime time.Time
	Mtime time.Time
	Id    string
	Name  string
}

func (A) _Table() string { return "as" }

type A_Update_Fields struct {
}

type A_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func A_Pk(v int64) A_Pk_Field {
	return A_Pk_Field{_set: true, _value: v}
}

func (f A_Pk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type A_Ctime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func A_Ctime(v time.Time) A_Ctime_Field {
	return A_Ctime_Field{_set: true, _value: v}
}

func (f A_Ctime_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type A_Mtime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func A_Mtime(v time.Time) A_Mtime_Field {
	return A_Mtime_Field{_set: true, _value: v}
}

func (f A_Mtime_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type A_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func A_Id(v string) A_Id_Field {
	return A_Id_Field{_set: true, _value: v}
}

func (f A_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type A_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func A_Name(v string) A_Name_Field {
	return A_Name_Field{_set: true, _value: v}
}

func (f A_Name_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type B struct {
	Pk   int64
	Id   string
	Data string
}

func (B) _Table() string { return "bs" }

type B_Update_Fields struct {
	Data B_Data_Field
}

type B_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func B_Pk(v int64) B_Pk_Field {
	return B_Pk_Field{_set: true, _value: v}
}

func (f B_Pk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type B_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func B_Id(v string) B_Id_Field {
	return B_Id_Field{_set: true, _value: v}
}

func (f B_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type B_Data_Field struct {
	_set   bool
	_null  bool
	_value string
}

func B_Data(v string) B_Data_Field {
	return B_Data_Field{_set: true, _value: v}
}

func (f B_Data_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo struct {
	Id             int64
	Int            int
	Int64          int64
	Uint           uint
	Uint64         uint64
	Float          float32
	Float64        float64
	String         string
	Blob           []byte
	Timestamp      time.Time
	Utimestamp     time.Time
	Bool           bool
	Date           time.Time
	Json           []byte
	NullInt        *int
	NullInt64      *int64
	NullUint       *uint
	NullUint64     *uint64
	NullFloat      *float32
	NullFloat64    *float64
	NullString     *string
	NullBlob       []byte
	NullTimestamp  *time.Time
	NullUtimestamp *time.Time
	NullBool       *bool
	NullDate       *time.Time
	NullJson       []byte
}

func (Foo) _Table() string { return "foos" }

type Foo_Create_Fields struct {
	NullInt        Foo_NullInt_Field
	NullInt64      Foo_NullInt64_Field
	NullUint       Foo_NullUint_Field
	NullUint64     Foo_NullUint64_Field
	NullFloat      Foo_NullFloat_Field
	NullFloat64    Foo_NullFloat64_Field
	NullString     Foo_NullString_Field
	NullBlob       Foo_NullBlob_Field
	NullTimestamp  Foo_NullTimestamp_Field
	NullUtimestamp Foo_NullUtimestamp_Field
	NullBool       Foo_NullBool_Field
	NullDate       Foo_NullDate_Field
	NullJson       Foo_NullJson_Field
}

type Foo_Update_Fields struct {
	Int            Foo_Int_Field
	Int64          Foo_Int64_Field
	Uint           Foo_Uint_Field
	Uint64         Foo_Uint64_Field
	Float          Foo_Float_Field
	Float64        Foo_Float64_Field
	String         Foo_String_Field
	Blob           Foo_Blob_Field
	Timestamp      Foo_Timestamp_Field
	Bool           Foo_Bool_Field
	Date           Foo_Date_Field
	Json           Foo_Json_Field
	NullInt        Foo_NullInt_Field
	NullInt64      Foo_NullInt64_Field
	NullUint       Foo_NullUint_Field
	NullUint64     Foo_NullUint64_Field
	NullFloat      Foo_NullFloat_Field
	NullFloat64    Foo_NullFloat64_Field
	NullString     Foo_NullString_Field
	NullBlob       Foo_NullBlob_Field
	NullTimestamp  Foo_NullTimestamp_Field
	NullUtimestamp Foo_NullUtimestamp_Field
	NullBool       Foo_NullBool_Field
	NullJson       Foo_NullJson_Field
}

type Foo_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Foo_Id(v int64) Foo_Id_Field {
	return Foo_Id_Field{_set: true, _value: v}
}

func (f Foo_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Int_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Foo_Int(v int) Foo_Int_Field {
	return Foo_Int_Field{_set: true, _value: v}
}

func (f Foo_Int_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Int64_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Foo_Int64(v int64) Foo_Int64_Field {
	return Foo_Int64_Field{_set: true, _value: v}
}

func (f Foo_Int64_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Uint_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func Foo_Uint(v uint) Foo_Uint_Field {
	return Foo_Uint_Field{_set: true, _value: v}
}

func (f Foo_Uint_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Uint64_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func Foo_Uint64(v uint64) Foo_Uint64_Field {
	return Foo_Uint64_Field{_set: true, _value: v}
}

func (f Foo_Uint64_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Float_Field struct {
	_set   bool
	_null  bool
	_value float32
}

func Foo_Float(v float32) Foo_Float_Field {
	return Foo_Float_Field{_set: true, _value: v}
}

func (f Foo_Float_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Float64_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Foo_Float64(v float64) Foo_Float64_Field {
	return Foo_Float64_Field{_set: true, _value: v}
}

func (f Foo_Float64_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_String_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Foo_String(v string) Foo_String_Field {
	return Foo_String_Field{_set: true, _value: v}
}

func (f Foo_String_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Blob_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Foo_Blob(v []byte) Foo_Blob_Field {
	return Foo_Blob_Field{_set: true, _value: v}
}

func (f Foo_Blob_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Timestamp_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Foo_Timestamp(v time.Time) Foo_Timestamp_Field {
	return Foo_Timestamp_Field{_set: true, _value: v}
}

func (f Foo_Timestamp_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Utimestamp_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Foo_Utimestamp(v time.Time) Foo_Utimestamp_Field {
	v = toUTC(v)
	return Foo_Utimestamp_Field{_set: true, _value: v}
}

func (f Foo_Utimestamp_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Bool_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func Foo_Bool(v bool) Foo_Bool_Field {
	return Foo_Bool_Field{_set: true, _value: v}
}

func (f Foo_Bool_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Date_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Foo_Date(v time.Time) Foo_Date_Field {
	v = toDate(v)
	return Foo_Date_Field{_set: true, _value: v}
}

func (f Foo_Date_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_Json_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Foo_Json(v []byte) Foo_Json_Field {
	return Foo_Json_Field{_set: true, _value: v}
}

func (f Foo_Json_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullInt_Field struct {
	_set   bool
	_null  bool
	_value *int
}

func Foo_NullInt(v int) Foo_NullInt_Field {
	return Foo_NullInt_Field{_set: true, _value: &v}
}

func Foo_NullInt_Raw(v *int) Foo_NullInt_Field {
	if v == nil {
		return Foo_NullInt_Null()
	}
	return Foo_NullInt(*v)
}

func Foo_NullInt_Null() Foo_NullInt_Field {
	return Foo_NullInt_Field{_set: true, _null: true}
}

func (f Foo_NullInt_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullInt_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullInt64_Field struct {
	_set   bool
	_null  bool
	_value *int64
}

func Foo_NullInt64(v int64) Foo_NullInt64_Field {
	return Foo_NullInt64_Field{_set: true, _value: &v}
}

func Foo_NullInt64_Raw(v *int64) Foo_NullInt64_Field {
	if v == nil {
		return Foo_NullInt64_Null()
	}
	return Foo_NullInt64(*v)
}

func Foo_NullInt64_Null() Foo_NullInt64_Field {
	return Foo_NullInt64_Field{_set: true, _null: true}
}

func (f Foo_NullInt64_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullInt64_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullUint_Field struct {
	_set   bool
	_null  bool
	_value *uint
}

func Foo_NullUint(v uint) Foo_NullUint_Field {
	return Foo_NullUint_Field{_set: true, _value: &v}
}

func Foo_NullUint_Raw(v *uint) Foo_NullUint_Field {
	if v == nil {
		return Foo_NullUint_Null()
	}
	return Foo_NullUint(*v)
}

func Foo_NullUint_Null() Foo_NullUint_Field {
	return Foo_NullUint_Field{_set: true, _null: true}
}

func (f Foo_NullUint_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullUint_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullUint64_Field struct {
	_set   bool
	_null  bool
	_value *uint64
}

func Foo_NullUint64(v uint64) Foo_NullUint64_Field {
	return Foo_NullUint64_Field{_set: true, _value: &v}
}

func Foo_NullUint64_Raw(v *uint64) Foo_NullUint64_Field {
	if v == nil {
		return Foo_NullUint64_Null()
	}
	return Foo_NullUint64(*v)
}

func Foo_NullUint64_Null() Foo_NullUint64_Field {
	return Foo_NullUint64_Field{_set: true, _null: true}
}

func (f Foo_NullUint64_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullUint64_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullFloat_Field struct {
	_set   bool
	_null  bool
	_value *float32
}

func Foo_NullFloat(v float32) Foo_NullFloat_Field {
	return Foo_NullFloat_Field{_set: true, _value: &v}
}

func Foo_NullFloat_Raw(v *float32) Foo_NullFloat_Field {
	if v == nil {
		return Foo_NullFloat_Null()
	}
	return Foo_NullFloat(*v)
}

func Foo_NullFloat_Null() Foo_NullFloat_Field {
	return Foo_NullFloat_Field{_set: true, _null: true}
}

func (f Foo_NullFloat_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullFloat_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullFloat64_Field struct {
	_set   bool
	_null  bool
	_value *float64
}

func Foo_NullFloat64(v float64) Foo_NullFloat64_Field {
	return Foo_NullFloat64_Field{_set: true, _value: &v}
}

func Foo_NullFloat64_Raw(v *float64) Foo_NullFloat64_Field {
	if v == nil {
		return Foo_NullFloat64_Null()
	}
	return Foo_NullFloat64(*v)
}

func Foo_NullFloat64_Null() Foo_NullFloat64_Field {
	return Foo_NullFloat64_Field{_set: true, _null: true}
}

func (f Foo_NullFloat64_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullFloat64_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullString_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func Foo_NullString(v string) Foo_NullString_Field {
	return Foo_NullString_Field{_set: true, _value: &v}
}

func Foo_NullString_Raw(v *string) Foo_NullString_Field {
	if v == nil {
		return Foo_NullString_Null()
	}
	return Foo_NullString(*v)
}

func Foo_NullString_Null() Foo_NullString_Field {
	return Foo_NullString_Field{_set: true, _null: true}
}

func (f Foo_NullString_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullString_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullBlob_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Foo_NullBlob(v []byte) Foo_NullBlob_Field {
	return Foo_NullBlob_Field{_set: true, _value: v}
}

func Foo_NullBlob_Raw(v []byte) Foo_NullBlob_Field {
	if v == nil {
		return Foo_NullBlob_Null()
	}
	return Foo_NullBlob(v)
}

func Foo_NullBlob_Null() Foo_NullBlob_Field {
	return Foo_NullBlob_Field{_set: true, _null: true}
}

func (f Foo_NullBlob_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullBlob_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullTimestamp_Field struct {
	_set   bool
	_null  bool
	_value *time.Time
}

func Foo_NullTimestamp(v time.Time) Foo_NullTimestamp_Field {
	return Foo_NullTimestamp_Field{_set: true, _value: &v}
}

func Foo_NullTimestamp_Raw(v *time.Time) Foo_NullTimestamp_Field {
	if v == nil {
		return Foo_NullTimestamp_Null()
	}
	return Foo_NullTimestamp(*v)
}

func Foo_NullTimestamp_Null() Foo_NullTimestamp_Field {
	return Foo_NullTimestamp_Field{_set: true, _null: true}
}

func (f Foo_NullTimestamp_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullTimestamp_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullUtimestamp_Field struct {
	_set   bool
	_null  bool
	_value *time.Time
}

func Foo_NullUtimestamp(v time.Time) Foo_NullUtimestamp_Field {
	v = toUTC(v)
	return Foo_NullUtimestamp_Field{_set: true, _value: &v}
}

func Foo_NullUtimestamp_Raw(v *time.Time) Foo_NullUtimestamp_Field {
	if v == nil {
		return Foo_NullUtimestamp_Null()
	}
	return Foo_NullUtimestamp(*v)
}

func Foo_NullUtimestamp_Null() Foo_NullUtimestamp_Field {
	return Foo_NullUtimestamp_Field{_set: true, _null: true}
}

func (f Foo_NullUtimestamp_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullUtimestamp_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullBool_Field struct {
	_set   bool
	_null  bool
	_value *bool
}

func Foo_NullBool(v bool) Foo_NullBool_Field {
	return Foo_NullBool_Field{_set: true, _value: &v}
}

func Foo_NullBool_Raw(v *bool) Foo_NullBool_Field {
	if v == nil {
		return Foo_NullBool_Null()
	}
	return Foo_NullBool(*v)
}

func Foo_NullBool_Null() Foo_NullBool_Field {
	return Foo_NullBool_Field{_set: true, _null: true}
}

func (f Foo_NullBool_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullBool_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullDate_Field struct {
	_set   bool
	_null  bool
	_value *time.Time
}

func Foo_NullDate(v time.Time) Foo_NullDate_Field {
	v = toDate(v)
	return Foo_NullDate_Field{_set: true, _value: &v}
}

func Foo_NullDate_Raw(v *time.Time) Foo_NullDate_Field {
	if v == nil {
		return Foo_NullDate_Null()
	}
	return Foo_NullDate(*v)
}

func Foo_NullDate_Null() Foo_NullDate_Field {
	return Foo_NullDate_Field{_set: true, _null: true}
}

func (f Foo_NullDate_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullDate_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type Foo_NullJson_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Foo_NullJson(v []byte) Foo_NullJson_Field {
	return Foo_NullJson_Field{_set: true, _value: v}
}

func Foo_NullJson_Raw(v []byte) Foo_NullJson_Field {
	if v == nil {
		return Foo_NullJson_Null()
	}
	return Foo_NullJson(v)
}

func Foo_NullJson_Null() Foo_NullJson_Field {
	return Foo_NullJson_Field{_set: true, _null: true}
}

func (f Foo_NullJson_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f Foo_NullJson_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type AB struct {
	BPk int64
	APk int64
}

func (AB) _Table() string { return "a_bs" }

type AB_Update_Fields struct {
}

type AB_BPk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AB_BPk(v int64) AB_BPk_Field {
	return AB_BPk_Field{_set: true, _value: v}
}

func (f AB_BPk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type AB_APk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AB_APk(v int64) AB_APk_Field {
	return AB_APk_Field{_set: true, _value: v}
}

func (f AB_APk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type C struct {
	Pk  int64
	Id  string
	BPk int64
}

func (C) _Table() string { return "cs" }

type C_Update_Fields struct {
}

type C_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func C_Pk(v int64) C_Pk_Field {
	return C_Pk_Field{_set: true, _value: v}
}

func (f C_Pk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type C_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func C_Id(v string) C_Id_Field {
	return C_Id_Field{_set: true, _value: v}
}

func (f C_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type C_BPk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func C_BPk(v int64) C_BPk_Field {
	return C_BPk_Field{_set: true, _value: v}
}

func (f C_BPk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type E struct {
	Pk  int64
	Id  string
	AId string
}

func (E) _Table() string { return "es" }

type E_Update_Fields struct {
}

type E_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func E_Pk(v int64) E_Pk_Field {
	return E_Pk_Field{_set: true, _value: v}
}

func (f E_Pk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type E_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func E_Id(v string) E_Id_Field {
	return E_Id_Field{_set: true, _value: v}
}

func (f E_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type E_AId_Field struct {
	_set   bool
	_null  bool
	_value string
}

func E_AId(v string) E_AId_Field {
	return E_AId_Field{_set: true, _value: v}
}

func (f E_AId_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type D struct {
	Pk    int64
	Id    string
	Alias *string
	Date  time.Time
	EId   string
	AId   string
}

func (D) _Table() string { return "ds" }

type D_Create_Fields struct {
	Alias D_Alias_Field
}

type D_Update_Fields struct {
	Alias D_Alias_Field
}

type D_Pk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func D_Pk(v int64) D_Pk_Field {
	return D_Pk_Field{_set: true, _value: v}
}

func (f D_Pk_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type D_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func D_Id(v string) D_Id_Field {
	return D_Id_Field{_set: true, _value: v}
}

func (f D_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type D_Alias_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func D_Alias(v string) D_Alias_Field {
	return D_Alias_Field{_set: true, _value: &v}
}

func D_Alias_Raw(v *string) D_Alias_Field {
	if v == nil {
		return D_Alias_Null()
	}
	return D_Alias(*v)
}

func D_Alias_Null() D_Alias_Field {
	return D_Alias_Field{_set: true, _null: true}
}

func (f D_Alias_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f D_Alias_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type D_Date_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func D_Date(v time.Time) D_Date_Field {
	return D_Date_Field{_set: true, _value: v}
}

func (f D_Date_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type D_EId_Field struct {
	_set   bool
	_null  bool
	_value string
}

func D_EId(v string) D_EId_Field {
	return D_EId_Field{_set: true, _value: v}
}

func (f D_EId_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type D_AId_Field struct {
	_set   bool
	_null  bool
	_value string
}

func D_AId(v string) D_AId_Field {
	return D_AId_Field{_set: true, _value: v}
}

func (f D_AId_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	// Rebind gives the opportunity to rewrite provided SQL into a SQL dialect.
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_RenderAll(dialect __sqlbundle_Dialect, sqls []__sqlbundle_SQL, ops ...__sqlbundle_RenderOp) []string {
	var rs []string
	for _, sql := range sqls {
		rs = append(rs, __sqlbundle_Render(dialect, sql, ops...))
	}
	return rs
}

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_cockroach struct{}

func (p __sqlbundle_cockroach) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgx struct{}

func (p __sqlbundle_pgx) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgxcockroach struct{}

func (p __sqlbundle_pgxcockroach) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_spanner struct{}

func (p __sqlbundle_spanner) Rebind(sql string) string {
	return sql
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime or possibly embed time
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string {
	if h.SQL == nil {
		return ""
	}
	return h.SQL.Render()
}

//
// end runtime support for building sql statements
//

type Bool_Int_Row struct {
	Bool bool
	Int  int
}

type Paged_A_By_B_Id_Continuation struct {
	_value_pk int64
	_set      bool
}

type Paged_D_By_AId_Continuation struct {
	_value_pk int64
	_set      bool
}

type Paged_E_By_AId_Continuation struct {
	_value_pk int64
	_set      bool
}

type Paged_Foo_Continuation struct {
	_value_id int64
	_set      bool
}

func (obj *sqlite3Impl) Create_E(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {
	__id_val := e_id.value()
	__a_id_val := e_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO es ( id, a_id ) VALUES ( ?, ? ) RETURNING es.pk, es.id, es.a_id")

	var __values []any
	__values = append(__values, __id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return e, nil

}

func (obj *sqlite3Impl) Create_D(ctx context.Context,
	d_id D_Id_Field,
	d_e_id D_EId_Field,
	d_a_id D_AId_Field,
	optional D_Create_Fields) (
	d *D, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := d_id.value()
	__alias_val := optional.Alias.value()
	__date_val := __now
	__e_id_val := d_e_id.value()
	__a_id_val := d_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ? ) RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __values []any
	__values = append(__values, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *sqlite3Impl) RawCreate_D(ctx context.Context,
	raw_d *D) (
	d *D, err error) {

	__pk_val := D_Pk(raw_d.Pk).value()
	__id_val := D_Id(raw_d.Id).value()
	__alias_val := D_Alias_Raw(raw_d.Alias).value()
	__date_val := D_Date(raw_d.Date).value()
	__e_id_val := D_EId(raw_d.EId).value()
	__a_id_val := D_AId(raw_d.AId).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( pk, id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ?, ? ) RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *sqlite3Impl) Create_A(ctx context.Context,
	a_id A_Id_Field,
	a_name A_Name_Field) (
	a *A, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__ctime_val := __now
	__mtime_val := __now
	__id_val := a_id.value()
	__name_val := a_name.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO as ( ctime, mtime, id, name ) VALUES ( ?, ?, ?, ? ) RETURNING as.pk, as.ctime, as.mtime, as.id, as.name")

	var __values []any
	__values = append(__values, __ctime_val, __mtime_val, __id_val, __name_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil

}

func (obj *sqlite3Impl) Create_AB(ctx context.Context,
	a_b_b_pk AB_BPk_Field,
	a_b_a_pk AB_APk_Field) (
	a_b *AB, err error) {
	__b_pk_val := a_b_b_pk.value()
	__a_pk_val := a_b_a_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO a_bs ( b_pk, a_pk ) VALUES ( ?, ? ) RETURNING a_bs.b_pk, a_bs.a_pk")

	var __values []any
	__values = append(__values, __b_pk_val, __a_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a_b = &AB{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a_b.BPk, &a_b.APk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a_b, nil

}

func (obj *sqlite3Impl) Create_C(ctx context.Context,
	c_id C_Id_Field,
	c_b_pk C_BPk_Field) (
	c *C, err error) {
	__id_val := c_id.value()
	__b_pk_val := c_b_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO cs ( id, b_pk ) VALUES ( ?, ? ) RETURNING cs.pk, cs.id, cs.b_pk")

	var __values []any
	__values = append(__values, __id_val, __b_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return c, nil

}

func (obj *sqlite3Impl) Create_B(ctx context.Context,
	b_id B_Id_Field,
	b_data B_Data_Field) (
	b *B, err error) {
	__id_val := b_id.value()
	__data_val := b_data.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bs ( id, data ) VALUES ( ?, ? ) RETURNING bs.pk, bs.id, bs.data")

	var __values []any
	__values = append(__values, __id_val, __data_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil

}

func (obj *sqlite3Impl) Create_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	foo *Foo, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := foo_json.value()
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := optional.NullJson.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *sqlite3Impl) RawCreate_Foo(ctx context.Context,
	raw_foo *Foo) (
	foo *Foo, err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := Foo_Json(raw_foo.Json).value()
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := Foo_NullJson_Raw(raw_foo.NullJson).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *sqlite3Impl) CreateNoReturn_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := foo_json.value()
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := optional.NullJson.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) RawCreateNoReturn_Foo(ctx context.Context,
	raw_foo *Foo) (
	err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := Foo_Json(raw_foo.Json).value()
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := Foo_NullJson_Raw(raw_foo.NullJson).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	_, err = obj.driver.ExecContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *sqlite3Impl) Has_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM es WHERE es.id = ? AND es.a_id = ? )")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *sqlite3Impl) Get_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return (*E)(nil), obj.makeErr(err)
	}
	return e, nil

}

func (obj *sqlite3Impl) Paged_E_By_AId(ctx context.Context,
	e_a_id E_AId_Field,
	limit int, start *Paged_E_By_AId_Continuation) (
	rows []*E, next *Paged_E_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? AND (es.pk) > ? ORDER BY es.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? ORDER BY es.pk LIMIT ?")

	var __values []any
	__values = append(__values, e_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_E_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		e := &E{}
		err = __rows.Scan(&e.Pk, &e.Id, &e.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, e)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Get_D_By_Id(ctx context.Context,
	d_id D_Id_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ?")

	var __values []any
	__values = append(__values, d_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *sqlite3Impl) Get_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *sqlite3Impl) Get_D_By_Alias_And_AId(ctx context.Context,
	d_alias D_Alias_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "ds.alias", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE "), __cond_0, __sqlbundle_Literal(" AND ds.a_id = ?")}}

	var __values []any
	if !d_alias.isnull() {
		__cond_0.Null = false
		__values = append(__values, d_alias.value())
	}
	__values = append(__values, d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *sqlite3Impl) Paged_D_By_AId(ctx context.Context,
	d_a_id D_AId_Field,
	limit int, start *Paged_D_By_AId_Continuation) (
	rows []*D, next *Paged_D_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? AND (ds.pk) > ? ORDER BY ds.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? ORDER BY ds.pk LIMIT ?")

	var __values []any
	__values = append(__values, d_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_D_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		d := &D{}
		err = __rows.Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, d)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Get_A_By_Pk(ctx context.Context,
	a_pk A_Pk_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as WHERE as.pk = ?")

	var __values []any
	__values = append(__values, a_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *sqlite3Impl) Get_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *sqlite3Impl) Get_A_By_A_Name_And_B_Id(ctx context.Context,
	a_name A_Name_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.name = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_name.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *sqlite3Impl) Paged_A_By_B_Id(ctx context.Context,
	b_id B_Id_Field,
	limit int, start *Paged_A_By_B_Id_Continuation) (
	rows []*A, next *Paged_A_By_B_Id_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? AND (as.pk) > ? ORDER BY as.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? ORDER BY as.pk LIMIT ?")

	var __values []any
	__values = append(__values, b_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_A_By_B_Id_Continuation
	__continuation._set = true

	for __rows.Next() {
		a := &A{}
		err = __rows.Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, a)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Get_C_By_Id(ctx context.Context,
	c_id C_Id_Field) (
	c *C, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cs.pk, cs.id, cs.b_pk FROM cs WHERE cs.id = ?")

	var __values []any
	__values = append(__values, c_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return (*C)(nil), obj.makeErr(err)
	}
	return c, nil

}

func (obj *sqlite3Impl) Get_B_By_Pk(ctx context.Context,
	b_pk B_Pk_Field) (
	b *B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.pk = ?")

	var __values []any
	__values = append(__values, b_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return (*B)(nil), obj.makeErr(err)
	}
	return b, nil

}

func (obj *sqlite3Impl) All_B_By_Data(ctx context.Context,
	b_data B_Data_Field) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.data = ?")

	var __values []any
	__values = append(__values, b_data.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_B(ctx context.Context) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_Foo(ctx context.Context) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Count_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Has_Foo(ctx context.Context) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos )")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *sqlite3Impl) Limited_Foo(ctx context.Context,
	limit int, offset int64) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos LIMIT ? OFFSET ?")

	var __values []any

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Paged_Foo(ctx context.Context,
	limit int, start *Paged_Foo_Continuation) (
	rows []*Foo, next *Paged_Foo_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos WHERE (foos.id) > ? ORDER BY foos.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos ORDER BY foos.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_Foo_Continuation
	__continuation._set = true

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Count_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Has_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos WHERE foos.id = ? )")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *sqlite3Impl) Find_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return (*Foo)(nil), nil
	}
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *sqlite3Impl) Get_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *sqlite3Impl) First_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ? LIMIT 1 OFFSET 0")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) All_Foo_Bool_Foo_Int(ctx context.Context) (
	rows []*Bool_Int_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.bool, foos.int FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Bool_Int_Row{}
		err = __rows.Scan(&row.Bool, &row.Int)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) First_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field) (
	foo *Foo, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" LIMIT 1 OFFSET 0")}}

	var __values []any
	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__values = append(__values, foo_null_int.value())
	}
	__values = append(__values, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__values = append(__values, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__values = append(__values, foo_null_uint.value())
	}
	__values = append(__values, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__values = append(__values, foo_null_uint64_not.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_Int_Equal_Number(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.int = 3 LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Int_Equal_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_NullInt_Is_Null(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_int is NULL LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullInt_Is_Null")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_String_Equal_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = 'boo' LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_Lower_String(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = ? LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_Lower_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_String_Equal_Lower_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower('BOO') LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_Bool_Equal_True(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.bool = 1 LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Bool_Equal_True")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_By_NullBool_Equal_False(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_bool = 0 LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullBool_Equal_False")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_OrderBy_Asc_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos ORDER BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_OrderBy_Asc_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Find_Foo_GroupBy_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos GROUP BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_GroupBy_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *sqlite3Impl) Update_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field,
	update D_Update_Fields) (
	d *D, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE ds SET "), __sets, __sqlbundle_Literal(" WHERE ds.id = ? AND ds.a_id = ? RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Alias._set {
		__values = append(__values, update.Alias.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("alias = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, d_id.value(), d_a_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil
}

func (obj *sqlite3Impl) Update_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field,
	update A_Update_Fields) (
	a *A, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE as SET "), __sets, __sqlbundle_Literal(" WHERE pk IN (SELECT pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?) RETURNING as.pk, as.ctime, as.mtime, as.id, as.name")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("mtime = ?"))

	__args = append(__args, a_id.value(), b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil
}

func (obj *sqlite3Impl) Update_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	b *B, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ? RETURNING bs.pk, bs.id, bs.data")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil
}

func (obj *sqlite3Impl) UpdateNoReturn_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Update_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ? RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *sqlite3Impl) UpdateNoReturn_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *sqlite3Impl) Update_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not_And_Id(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}
	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" AND foos.id = ? RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__args = append(__args, foo_null_int.value())
	}
	__args = append(__args, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__args = append(__args, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__args = append(__args, foo_null_uint.value())
	}
	__args = append(__args, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__args = append(__args, foo_null_uint64_not.value())
	}
	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *sqlite3Impl) Delete_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_E(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Delete_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM as WHERE as.pk IN (SELECT as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?)")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM ds;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM es;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM cs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM a_bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM foos;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM as;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *pgxImpl) Create_E(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {
	__id_val := e_id.value()
	__a_id_val := e_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO es ( id, a_id ) VALUES ( ?, ? ) RETURNING es.pk, es.id, es.a_id")

	var __values []any
	__values = append(__values, __id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return e, nil

}

func (obj *pgxImpl) Create_D(ctx context.Context,
	d_id D_Id_Field,
	d_e_id D_EId_Field,
	d_a_id D_AId_Field,
	optional D_Create_Fields) (
	d *D, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := d_id.value()
	__alias_val := optional.Alias.value()
	__date_val := __now
	__e_id_val := d_e_id.value()
	__a_id_val := d_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ? ) RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __values []any
	__values = append(__values, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxImpl) RawCreate_D(ctx context.Context,
	raw_d *D) (
	d *D, err error) {

	__pk_val := D_Pk(raw_d.Pk).value()
	__id_val := D_Id(raw_d.Id).value()
	__alias_val := D_Alias_Raw(raw_d.Alias).value()
	__date_val := D_Date(raw_d.Date).value()
	__e_id_val := D_EId(raw_d.EId).value()
	__a_id_val := D_AId(raw_d.AId).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( pk, id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ?, ? ) RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxImpl) Create_A(ctx context.Context,
	a_id A_Id_Field,
	a_name A_Name_Field) (
	a *A, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__ctime_val := __now
	__mtime_val := __now
	__id_val := a_id.value()
	__name_val := a_name.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO as ( ctime, mtime, id, name ) VALUES ( ?, ?, ?, ? ) RETURNING as.pk, as.ctime, as.mtime, as.id, as.name")

	var __values []any
	__values = append(__values, __ctime_val, __mtime_val, __id_val, __name_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxImpl) Create_AB(ctx context.Context,
	a_b_b_pk AB_BPk_Field,
	a_b_a_pk AB_APk_Field) (
	a_b *AB, err error) {
	__b_pk_val := a_b_b_pk.value()
	__a_pk_val := a_b_a_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO a_bs ( b_pk, a_pk ) VALUES ( ?, ? ) RETURNING a_bs.b_pk, a_bs.a_pk")

	var __values []any
	__values = append(__values, __b_pk_val, __a_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a_b = &AB{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a_b.BPk, &a_b.APk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a_b, nil

}

func (obj *pgxImpl) Create_C(ctx context.Context,
	c_id C_Id_Field,
	c_b_pk C_BPk_Field) (
	c *C, err error) {
	__id_val := c_id.value()
	__b_pk_val := c_b_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO cs ( id, b_pk ) VALUES ( ?, ? ) RETURNING cs.pk, cs.id, cs.b_pk")

	var __values []any
	__values = append(__values, __id_val, __b_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return c, nil

}

func (obj *pgxImpl) Create_B(ctx context.Context,
	b_id B_Id_Field,
	b_data B_Data_Field) (
	b *B, err error) {
	__id_val := b_id.value()
	__data_val := b_data.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bs ( id, data ) VALUES ( ?, ? ) RETURNING bs.pk, bs.id, bs.data")

	var __values []any
	__values = append(__values, __id_val, __data_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil

}

func (obj *pgxImpl) Create_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	foo *Foo, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := foo_json.value()
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := optional.NullJson.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxImpl) RawCreate_Foo(ctx context.Context,
	raw_foo *Foo) (
	foo *Foo, err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := Foo_Json(raw_foo.Json).value()
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := Foo_NullJson_Raw(raw_foo.NullJson).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxImpl) CreateNoReturn_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := foo_json.value()
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := optional.NullJson.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *pgxImpl) RawCreateNoReturn_Foo(ctx context.Context,
	raw_foo *Foo) (
	err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := Foo_Json(raw_foo.Json).value()
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := Foo_NullJson_Raw(raw_foo.NullJson).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	_, err = obj.driver.ExecContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *pgxImpl) Has_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM es WHERE es.id = ? AND es.a_id = ? )")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *pgxImpl) Get_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return (*E)(nil), obj.makeErr(err)
	}
	return e, nil

}

func (obj *pgxImpl) Paged_E_By_AId(ctx context.Context,
	e_a_id E_AId_Field,
	limit int, start *Paged_E_By_AId_Continuation) (
	rows []*E, next *Paged_E_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? AND (es.pk) > ? ORDER BY es.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? ORDER BY es.pk LIMIT ?")

	var __values []any
	__values = append(__values, e_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_E_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		e := &E{}
		err = __rows.Scan(&e.Pk, &e.Id, &e.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, e)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Get_D_By_Id(ctx context.Context,
	d_id D_Id_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ?")

	var __values []any
	__values = append(__values, d_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxImpl) Get_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxImpl) Get_D_By_Alias_And_AId(ctx context.Context,
	d_alias D_Alias_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "ds.alias", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE "), __cond_0, __sqlbundle_Literal(" AND ds.a_id = ?")}}

	var __values []any
	if !d_alias.isnull() {
		__cond_0.Null = false
		__values = append(__values, d_alias.value())
	}
	__values = append(__values, d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxImpl) Paged_D_By_AId(ctx context.Context,
	d_a_id D_AId_Field,
	limit int, start *Paged_D_By_AId_Continuation) (
	rows []*D, next *Paged_D_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? AND (ds.pk) > ? ORDER BY ds.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? ORDER BY ds.pk LIMIT ?")

	var __values []any
	__values = append(__values, d_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_D_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		d := &D{}
		err = __rows.Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, d)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Get_A_By_Pk(ctx context.Context,
	a_pk A_Pk_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as WHERE as.pk = ?")

	var __values []any
	__values = append(__values, a_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxImpl) Get_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxImpl) Get_A_By_A_Name_And_B_Id(ctx context.Context,
	a_name A_Name_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.name = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_name.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxImpl) Paged_A_By_B_Id(ctx context.Context,
	b_id B_Id_Field,
	limit int, start *Paged_A_By_B_Id_Continuation) (
	rows []*A, next *Paged_A_By_B_Id_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? AND (as.pk) > ? ORDER BY as.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? ORDER BY as.pk LIMIT ?")

	var __values []any
	__values = append(__values, b_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_A_By_B_Id_Continuation
	__continuation._set = true

	for __rows.Next() {
		a := &A{}
		err = __rows.Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, a)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Get_C_By_Id(ctx context.Context,
	c_id C_Id_Field) (
	c *C, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cs.pk, cs.id, cs.b_pk FROM cs WHERE cs.id = ?")

	var __values []any
	__values = append(__values, c_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return (*C)(nil), obj.makeErr(err)
	}
	return c, nil

}

func (obj *pgxImpl) Get_B_By_Pk(ctx context.Context,
	b_pk B_Pk_Field) (
	b *B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.pk = ?")

	var __values []any
	__values = append(__values, b_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return (*B)(nil), obj.makeErr(err)
	}
	return b, nil

}

func (obj *pgxImpl) All_B_By_Data(ctx context.Context,
	b_data B_Data_Field) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.data = ?")

	var __values []any
	__values = append(__values, b_data.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxImpl) All_B(ctx context.Context) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxImpl) All_Foo(ctx context.Context) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxImpl) Count_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *pgxImpl) Has_Foo(ctx context.Context) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos )")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *pgxImpl) Limited_Foo(ctx context.Context,
	limit int, offset int64) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos LIMIT ? OFFSET ?")

	var __values []any

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxImpl) Paged_Foo(ctx context.Context,
	limit int, start *Paged_Foo_Continuation) (
	rows []*Foo, next *Paged_Foo_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos WHERE (foos.id) > ? ORDER BY foos.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos ORDER BY foos.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_Foo_Continuation
	__continuation._set = true

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Count_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *pgxImpl) Has_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos WHERE foos.id = ? )")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *pgxImpl) Find_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return (*Foo)(nil), nil
	}
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxImpl) Get_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxImpl) First_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ? LIMIT 1 OFFSET 0")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) All_Foo_Bool_Foo_Int(ctx context.Context) (
	rows []*Bool_Int_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.bool, foos.int FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Bool_Int_Row{}
		err = __rows.Scan(&row.Bool, &row.Int)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxImpl) First_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field) (
	foo *Foo, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" LIMIT 1 OFFSET 0")}}

	var __values []any
	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__values = append(__values, foo_null_int.value())
	}
	__values = append(__values, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__values = append(__values, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__values = append(__values, foo_null_uint.value())
	}
	__values = append(__values, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__values = append(__values, foo_null_uint64_not.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_Int_Equal_Number(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.int = 3 LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Int_Equal_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_NullInt_Is_Null(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_int is NULL LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullInt_Is_Null")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_String_Equal_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = 'boo' LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_Lower_String(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = ? LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_Lower_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_String_Equal_Lower_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower('BOO') LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_Bool_Equal_True(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.bool = true LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Bool_Equal_True")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_By_NullBool_Equal_False(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_bool = false LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullBool_Equal_False")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_OrderBy_Asc_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos ORDER BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_OrderBy_Asc_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Find_Foo_GroupBy_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos GROUP BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_GroupBy_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxImpl) Update_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field,
	update D_Update_Fields) (
	d *D, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE ds SET "), __sets, __sqlbundle_Literal(" WHERE ds.id = ? AND ds.a_id = ? RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Alias._set {
		__values = append(__values, update.Alias.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("alias = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, d_id.value(), d_a_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil
}

func (obj *pgxImpl) Update_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field,
	update A_Update_Fields) (
	a *A, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE as SET "), __sets, __sqlbundle_Literal(" WHERE pk IN (SELECT pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?) RETURNING as.pk, as.ctime, as.mtime, as.id, as.name")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("mtime = ?"))

	__args = append(__args, a_id.value(), b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil
}

func (obj *pgxImpl) Update_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	b *B, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ? RETURNING bs.pk, bs.id, bs.data")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil
}

func (obj *pgxImpl) UpdateNoReturn_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *pgxImpl) Update_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ? RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *pgxImpl) UpdateNoReturn_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *pgxImpl) Update_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not_And_Id(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}
	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" AND foos.id = ? RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__args = append(__args, foo_null_int.value())
	}
	__args = append(__args, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__args = append(__args, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__args = append(__args, foo_null_uint.value())
	}
	__args = append(__args, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__args = append(__args, foo_null_uint64_not.value())
	}
	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *pgxImpl) Delete_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *pgxImpl) Delete_E(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *pgxImpl) Delete_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *pgxImpl) Delete_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM as WHERE as.pk IN (SELECT as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?)")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *pgxImpl) Delete_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (impl pgxImpl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(*pgconn.PgError); ok {
		if e.Code[:2] == "23" {
			return e.ConstraintName, true
		}
	}
	return "", false
}

func (obj *pgxImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM ds;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM es;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM cs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM a_bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM foos;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM as;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *pgxcockroachImpl) Create_E(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {
	__id_val := e_id.value()
	__a_id_val := e_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO es ( id, a_id ) VALUES ( ?, ? ) RETURNING es.pk, es.id, es.a_id")

	var __values []any
	__values = append(__values, __id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return e, nil

}

func (obj *pgxcockroachImpl) Create_D(ctx context.Context,
	d_id D_Id_Field,
	d_e_id D_EId_Field,
	d_a_id D_AId_Field,
	optional D_Create_Fields) (
	d *D, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := d_id.value()
	__alias_val := optional.Alias.value()
	__date_val := __now
	__e_id_val := d_e_id.value()
	__a_id_val := d_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ? ) RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __values []any
	__values = append(__values, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxcockroachImpl) RawCreate_D(ctx context.Context,
	raw_d *D) (
	d *D, err error) {

	__pk_val := D_Pk(raw_d.Pk).value()
	__id_val := D_Id(raw_d.Id).value()
	__alias_val := D_Alias_Raw(raw_d.Alias).value()
	__date_val := D_Date(raw_d.Date).value()
	__e_id_val := D_EId(raw_d.EId).value()
	__a_id_val := D_AId(raw_d.AId).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( pk, id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ?, ? ) RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxcockroachImpl) Create_A(ctx context.Context,
	a_id A_Id_Field,
	a_name A_Name_Field) (
	a *A, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__ctime_val := __now
	__mtime_val := __now
	__id_val := a_id.value()
	__name_val := a_name.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO as ( ctime, mtime, id, name ) VALUES ( ?, ?, ?, ? ) RETURNING as.pk, as.ctime, as.mtime, as.id, as.name")

	var __values []any
	__values = append(__values, __ctime_val, __mtime_val, __id_val, __name_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxcockroachImpl) Create_AB(ctx context.Context,
	a_b_b_pk AB_BPk_Field,
	a_b_a_pk AB_APk_Field) (
	a_b *AB, err error) {
	__b_pk_val := a_b_b_pk.value()
	__a_pk_val := a_b_a_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO a_bs ( b_pk, a_pk ) VALUES ( ?, ? ) RETURNING a_bs.b_pk, a_bs.a_pk")

	var __values []any
	__values = append(__values, __b_pk_val, __a_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a_b = &AB{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a_b.BPk, &a_b.APk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a_b, nil

}

func (obj *pgxcockroachImpl) Create_C(ctx context.Context,
	c_id C_Id_Field,
	c_b_pk C_BPk_Field) (
	c *C, err error) {
	__id_val := c_id.value()
	__b_pk_val := c_b_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO cs ( id, b_pk ) VALUES ( ?, ? ) RETURNING cs.pk, cs.id, cs.b_pk")

	var __values []any
	__values = append(__values, __id_val, __b_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return c, nil

}

func (obj *pgxcockroachImpl) Create_B(ctx context.Context,
	b_id B_Id_Field,
	b_data B_Data_Field) (
	b *B, err error) {
	__id_val := b_id.value()
	__data_val := b_data.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bs ( id, data ) VALUES ( ?, ? ) RETURNING bs.pk, bs.id, bs.data")

	var __values []any
	__values = append(__values, __id_val, __data_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil

}

func (obj *pgxcockroachImpl) Create_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	foo *Foo, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := foo_json.value()
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := optional.NullJson.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxcockroachImpl) RawCreate_Foo(ctx context.Context,
	raw_foo *Foo) (
	foo *Foo, err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := Foo_Json(raw_foo.Json).value()
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := Foo_NullJson_Raw(raw_foo.NullJson).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxcockroachImpl) CreateNoReturn_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := foo_json.value()
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := optional.NullJson.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *pgxcockroachImpl) RawCreateNoReturn_Foo(ctx context.Context,
	raw_foo *Foo) (
	err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := Foo_Json(raw_foo.Json).value()
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := Foo_NullJson_Raw(raw_foo.NullJson).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	_, err = obj.driver.ExecContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *pgxcockroachImpl) Has_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM es WHERE es.id = ? AND es.a_id = ? )")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *pgxcockroachImpl) Get_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return (*E)(nil), obj.makeErr(err)
	}
	return e, nil

}

func (obj *pgxcockroachImpl) Paged_E_By_AId(ctx context.Context,
	e_a_id E_AId_Field,
	limit int, start *Paged_E_By_AId_Continuation) (
	rows []*E, next *Paged_E_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? AND (es.pk) > ? ORDER BY es.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? ORDER BY es.pk LIMIT ?")

	var __values []any
	__values = append(__values, e_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_E_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		e := &E{}
		err = __rows.Scan(&e.Pk, &e.Id, &e.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, e)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Get_D_By_Id(ctx context.Context,
	d_id D_Id_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ?")

	var __values []any
	__values = append(__values, d_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxcockroachImpl) Get_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxcockroachImpl) Get_D_By_Alias_And_AId(ctx context.Context,
	d_alias D_Alias_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "ds.alias", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE "), __cond_0, __sqlbundle_Literal(" AND ds.a_id = ?")}}

	var __values []any
	if !d_alias.isnull() {
		__cond_0.Null = false
		__values = append(__values, d_alias.value())
	}
	__values = append(__values, d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *pgxcockroachImpl) Paged_D_By_AId(ctx context.Context,
	d_a_id D_AId_Field,
	limit int, start *Paged_D_By_AId_Continuation) (
	rows []*D, next *Paged_D_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? AND (ds.pk) > ? ORDER BY ds.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? ORDER BY ds.pk LIMIT ?")

	var __values []any
	__values = append(__values, d_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_D_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		d := &D{}
		err = __rows.Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, d)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Get_A_By_Pk(ctx context.Context,
	a_pk A_Pk_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as WHERE as.pk = ?")

	var __values []any
	__values = append(__values, a_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxcockroachImpl) Get_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxcockroachImpl) Get_A_By_A_Name_And_B_Id(ctx context.Context,
	a_name A_Name_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.name = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_name.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *pgxcockroachImpl) Paged_A_By_B_Id(ctx context.Context,
	b_id B_Id_Field,
	limit int, start *Paged_A_By_B_Id_Continuation) (
	rows []*A, next *Paged_A_By_B_Id_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? AND (as.pk) > ? ORDER BY as.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? ORDER BY as.pk LIMIT ?")

	var __values []any
	__values = append(__values, b_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_pk, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_A_By_B_Id_Continuation
	__continuation._set = true

	for __rows.Next() {
		a := &A{}
		err = __rows.Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, a)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Get_C_By_Id(ctx context.Context,
	c_id C_Id_Field) (
	c *C, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cs.pk, cs.id, cs.b_pk FROM cs WHERE cs.id = ?")

	var __values []any
	__values = append(__values, c_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return (*C)(nil), obj.makeErr(err)
	}
	return c, nil

}

func (obj *pgxcockroachImpl) Get_B_By_Pk(ctx context.Context,
	b_pk B_Pk_Field) (
	b *B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.pk = ?")

	var __values []any
	__values = append(__values, b_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return (*B)(nil), obj.makeErr(err)
	}
	return b, nil

}

func (obj *pgxcockroachImpl) All_B_By_Data(ctx context.Context,
	b_data B_Data_Field) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.data = ?")

	var __values []any
	__values = append(__values, b_data.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxcockroachImpl) All_B(ctx context.Context) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxcockroachImpl) All_Foo(ctx context.Context) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxcockroachImpl) Count_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *pgxcockroachImpl) Has_Foo(ctx context.Context) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos )")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *pgxcockroachImpl) Limited_Foo(ctx context.Context,
	limit int, offset int64) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos LIMIT ? OFFSET ?")

	var __values []any

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxcockroachImpl) Paged_Foo(ctx context.Context,
	limit int, start *Paged_Foo_Continuation) (
	rows []*Foo, next *Paged_Foo_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos WHERE (foos.id) > ? ORDER BY foos.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos ORDER BY foos.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_Foo_Continuation
	__continuation._set = true

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Count_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *pgxcockroachImpl) Has_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos WHERE foos.id = ? )")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return (*Foo)(nil), nil
	}
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxcockroachImpl) Get_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *pgxcockroachImpl) First_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ? LIMIT 1 OFFSET 0")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) All_Foo_Bool_Foo_Int(ctx context.Context) (
	rows []*Bool_Int_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.bool, foos.int FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Bool_Int_Row{}
		err = __rows.Scan(&row.Bool, &row.Int)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *pgxcockroachImpl) First_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field) (
	foo *Foo, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" LIMIT 1 OFFSET 0")}}

	var __values []any
	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__values = append(__values, foo_null_int.value())
	}
	__values = append(__values, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__values = append(__values, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__values = append(__values, foo_null_uint.value())
	}
	__values = append(__values, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__values = append(__values, foo_null_uint64_not.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_Int_Equal_Number(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.int = 3 LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Int_Equal_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_NullInt_Is_Null(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_int is NULL LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullInt_Is_Null")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_String_Equal_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = 'boo' LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_Lower_String(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = ? LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_Lower_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_String_Equal_Lower_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower('BOO') LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_Bool_Equal_True(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.bool = true LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Bool_Equal_True")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_By_NullBool_Equal_False(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_bool = false LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullBool_Equal_False")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_OrderBy_Asc_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos ORDER BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_OrderBy_Asc_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Find_Foo_GroupBy_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos GROUP BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_GroupBy_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *pgxcockroachImpl) Update_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field,
	update D_Update_Fields) (
	d *D, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE ds SET "), __sets, __sqlbundle_Literal(" WHERE ds.id = ? AND ds.a_id = ? RETURNING ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Alias._set {
		__values = append(__values, update.Alias.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("alias = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, d_id.value(), d_a_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil
}

func (obj *pgxcockroachImpl) Update_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field,
	update A_Update_Fields) (
	a *A, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE as SET "), __sets, __sqlbundle_Literal(" WHERE pk IN (SELECT pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?) RETURNING as.pk, as.ctime, as.mtime, as.id, as.name")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("mtime = ?"))

	__args = append(__args, a_id.value(), b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil
}

func (obj *pgxcockroachImpl) Update_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	b *B, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ? RETURNING bs.pk, bs.id, bs.data")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil
}

func (obj *pgxcockroachImpl) UpdateNoReturn_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *pgxcockroachImpl) Update_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ? RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *pgxcockroachImpl) UpdateNoReturn_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *pgxcockroachImpl) Update_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not_And_Id(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}
	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" AND foos.id = ? RETURNING foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}

	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}

	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}

	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}

	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}

	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}

	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}

	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}

	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}

	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}

	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}

	if update.Json._set {
		__values = append(__values, update.Json.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}

	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}

	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}

	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}

	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}

	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}

	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}

	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}

	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}

	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}

	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}

	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}

	if update.NullJson._set {
		__values = append(__values, update.NullJson.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__args = append(__args, foo_null_int.value())
	}
	__args = append(__args, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__args = append(__args, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__args = append(__args, foo_null_uint.value())
	}
	__args = append(__args, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__args = append(__args, foo_null_uint64_not.value())
	}
	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, &foo.Json, &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, &foo.NullJson)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *pgxcockroachImpl) Delete_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *pgxcockroachImpl) Delete_E(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *pgxcockroachImpl) Delete_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *pgxcockroachImpl) Delete_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM as WHERE as.pk IN (SELECT as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?)")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *pgxcockroachImpl) Delete_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (impl pgxcockroachImpl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(*pgconn.PgError); ok {
		if e.Code[:2] == "23" {
			return e.ConstraintName, true
		}
	}
	return "", false
}

func (obj *pgxcockroachImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM ds;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM es;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM cs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM a_bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM foos;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM as;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *spannerImpl) Create_E(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {
	__id_val := e_id.value()
	__a_id_val := e_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO es ( id, a_id ) VALUES ( ?, ? ) THEN RETURN es.pk, es.id, es.a_id")

	var __values []any
	__values = append(__values, __id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return e, nil

}

func (obj *spannerImpl) Create_D(ctx context.Context,
	d_id D_Id_Field,
	d_e_id D_EId_Field,
	d_a_id D_AId_Field,
	optional D_Create_Fields) (
	d *D, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := d_id.value()
	__alias_val := optional.Alias.value()
	__date_val := __now
	__e_id_val := d_e_id.value()
	__a_id_val := d_a_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ? ) THEN RETURN ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __values []any
	__values = append(__values, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *spannerImpl) RawCreate_D(ctx context.Context,
	raw_d *D) (
	d *D, err error) {

	__pk_val := D_Pk(raw_d.Pk).value()
	__id_val := D_Id(raw_d.Id).value()
	__alias_val := D_Alias_Raw(raw_d.Alias).value()
	__date_val := D_Date(raw_d.Date).value()
	__e_id_val := D_EId(raw_d.EId).value()
	__a_id_val := D_AId(raw_d.AId).value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO ds ( pk, id, alias, date, e_id, a_id ) VALUES ( ?, ?, ?, ?, ?, ? ) THEN RETURN ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __pk_val, __id_val, __alias_val, __date_val, __e_id_val, __a_id_val).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil

}

func (obj *spannerImpl) Create_A(ctx context.Context,
	a_id A_Id_Field,
	a_name A_Name_Field) (
	a *A, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__ctime_val := __now
	__mtime_val := __now
	__id_val := a_id.value()
	__name_val := a_name.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO as ( ctime, mtime, id, name ) VALUES ( ?, ?, ?, ? ) THEN RETURN as.pk, as.ctime, as.mtime, as.id, as.name")

	var __values []any
	__values = append(__values, __ctime_val, __mtime_val, __id_val, __name_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil

}

func (obj *spannerImpl) Create_AB(ctx context.Context,
	a_b_b_pk AB_BPk_Field,
	a_b_a_pk AB_APk_Field) (
	a_b *AB, err error) {
	__b_pk_val := a_b_b_pk.value()
	__a_pk_val := a_b_a_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO a_bs ( b_pk, a_pk ) VALUES ( ?, ? ) THEN RETURN a_bs.b_pk, a_bs.a_pk")

	var __values []any
	__values = append(__values, __b_pk_val, __a_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a_b = &AB{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&a_b.BPk, &a_b.APk)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a_b, nil

}

func (obj *spannerImpl) Create_C(ctx context.Context,
	c_id C_Id_Field,
	c_b_pk C_BPk_Field) (
	c *C, err error) {
	__id_val := c_id.value()
	__b_pk_val := c_b_pk.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO cs ( id, b_pk ) VALUES ( ?, ? ) THEN RETURN cs.pk, cs.id, cs.b_pk")

	var __values []any
	__values = append(__values, __id_val, __b_pk_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return c, nil

}

func (obj *spannerImpl) Create_B(ctx context.Context,
	b_id B_Id_Field,
	b_data B_Data_Field) (
	b *B, err error) {
	__id_val := b_id.value()
	__data_val := b_data.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bs ( id, data ) VALUES ( ?, ? ) THEN RETURN bs.pk, bs.id, bs.data")

	var __values []any
	__values = append(__values, __id_val, __data_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil

}

func (obj *spannerImpl) Create_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	foo *Foo, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := spannerConvertJSON(foo_json.value())
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := spannerConvertJSON(optional.NullJson.value())

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) THEN RETURN foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *spannerImpl) RawCreate_Foo(ctx context.Context,
	raw_foo *Foo) (
	foo *Foo, err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := spannerConvertJSON(Foo_Json(raw_foo.Json).value())
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := spannerConvertJSON(Foo_NullJson_Raw(raw_foo.NullJson).value())

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) THEN RETURN foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil

}

func (obj *spannerImpl) CreateNoReturn_Foo(ctx context.Context,
	foo_int Foo_Int_Field,
	foo_int64 Foo_Int64_Field,
	foo_uint Foo_Uint_Field,
	foo_uint64 Foo_Uint64_Field,
	foo_float Foo_Float_Field,
	foo_float64 Foo_Float64_Field,
	foo_string Foo_String_Field,
	foo_blob Foo_Blob_Field,
	foo_bool Foo_Bool_Field,
	foo_date Foo_Date_Field,
	foo_json Foo_Json_Field,
	optional Foo_Create_Fields) (
	err error) {

	__now := obj.db.Hooks.Now().UTC()
	__int_val := foo_int.value()
	__int64_val := foo_int64.value()
	__uint_val := foo_uint.value()
	__uint64_val := foo_uint64.value()
	__float_val := foo_float.value()
	__float64_val := foo_float64.value()
	__string_val := foo_string.value()
	__blob_val := foo_blob.value()
	__timestamp_val := __now
	__utimestamp_val := __now.UTC()
	__bool_val := foo_bool.value()
	__date_val := foo_date.value()
	__json_val := spannerConvertJSON(foo_json.value())
	__null_int_val := optional.NullInt.value()
	__null_int64_val := optional.NullInt64.value()
	__null_uint_val := optional.NullUint.value()
	__null_uint64_val := optional.NullUint64.value()
	__null_float_val := optional.NullFloat.value()
	__null_float64_val := optional.NullFloat64.value()
	__null_string_val := optional.NullString.value()
	__null_blob_val := optional.NullBlob.value()
	__null_timestamp_val := optional.NullTimestamp.value()
	__null_utimestamp_val := optional.NullUtimestamp.value()
	__null_bool_val := optional.NullBool.value()
	__null_date_val := optional.NullDate.value()
	__null_json_val := spannerConvertJSON(optional.NullJson.value())

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __values []any
	__values = append(__values, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *spannerImpl) RawCreateNoReturn_Foo(ctx context.Context,
	raw_foo *Foo) (
	err error) {

	__id_val := Foo_Id(raw_foo.Id).value()
	__int_val := Foo_Int(raw_foo.Int).value()
	__int64_val := Foo_Int64(raw_foo.Int64).value()
	__uint_val := Foo_Uint(raw_foo.Uint).value()
	__uint64_val := Foo_Uint64(raw_foo.Uint64).value()
	__float_val := Foo_Float(raw_foo.Float).value()
	__float64_val := Foo_Float64(raw_foo.Float64).value()
	__string_val := Foo_String(raw_foo.String).value()
	__blob_val := Foo_Blob(raw_foo.Blob).value()
	__timestamp_val := Foo_Timestamp(raw_foo.Timestamp).value()
	__utimestamp_val := Foo_Utimestamp(raw_foo.Utimestamp).value()
	__bool_val := Foo_Bool(raw_foo.Bool).value()
	__date_val := Foo_Date(raw_foo.Date).value()
	__json_val := spannerConvertJSON(Foo_Json(raw_foo.Json).value())
	__null_int_val := Foo_NullInt_Raw(raw_foo.NullInt).value()
	__null_int64_val := Foo_NullInt64_Raw(raw_foo.NullInt64).value()
	__null_uint_val := Foo_NullUint_Raw(raw_foo.NullUint).value()
	__null_uint64_val := Foo_NullUint64_Raw(raw_foo.NullUint64).value()
	__null_float_val := Foo_NullFloat_Raw(raw_foo.NullFloat).value()
	__null_float64_val := Foo_NullFloat64_Raw(raw_foo.NullFloat64).value()
	__null_string_val := Foo_NullString_Raw(raw_foo.NullString).value()
	__null_blob_val := Foo_NullBlob_Raw(raw_foo.NullBlob).value()
	__null_timestamp_val := Foo_NullTimestamp_Raw(raw_foo.NullTimestamp).value()
	__null_utimestamp_val := Foo_NullUtimestamp_Raw(raw_foo.NullUtimestamp).value()
	__null_bool_val := Foo_NullBool_Raw(raw_foo.NullBool).value()
	__null_date_val := Foo_NullDate_Raw(raw_foo.NullDate).value()
	__null_json_val := spannerConvertJSON(Foo_NullJson_Raw(raw_foo.NullJson).value())

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO foos ( id, int, int64, uint, uint64, float, float64, string, blob, timestamp, utimestamp, bool, date, json, null_int, null_int64, null_uint, null_uint64, null_float, null_float64, null_string, null_blob, null_timestamp, null_utimestamp, null_bool, null_date, null_json ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)

	_, err = obj.driver.ExecContext(ctx, __stmt, __id_val, __int_val, __int64_val, __uint_val, __uint64_val, __float_val, __float64_val, __string_val, __blob_val, __timestamp_val, __utimestamp_val, __bool_val, __date_val, __json_val, __null_int_val, __null_int64_val, __null_uint_val, __null_uint64_val, __null_float_val, __null_float64_val, __null_string_val, __null_blob_val, __null_timestamp_val, __null_utimestamp_val, __null_bool_val, __null_date_val, __null_json_val)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil

}

func (obj *spannerImpl) Has_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM es WHERE es.id = ? AND es.a_id = ? )")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *spannerImpl) Get_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	e *E, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	e = &E{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&e.Pk, &e.Id, &e.AId)
	if err != nil {
		return (*E)(nil), obj.makeErr(err)
	}
	return e, nil

}

func (obj *spannerImpl) Paged_E_By_AId(ctx context.Context,
	e_a_id E_AId_Field,
	limit int, start *Paged_E_By_AId_Continuation) (
	rows []*E, next *Paged_E_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? AND es.pk > ? ORDER BY es.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT es.pk, es.id, es.a_id, es.pk FROM es WHERE es.a_id = ? ORDER BY es.pk LIMIT ?")

	var __values []any
	__values = append(__values, e_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values,
			start._value_pk,
			limit,
		)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_E_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		e := &E{}
		err = __rows.Scan(&e.Pk, &e.Id, &e.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, e)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Get_D_By_Id(ctx context.Context,
	d_id D_Id_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ?")

	var __values []any
	__values = append(__values, d_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *spannerImpl) Get_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *spannerImpl) Get_D_By_Alias_And_AId(ctx context.Context,
	d_alias D_Alias_Field,
	d_a_id D_AId_Field) (
	d *D, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "ds.alias", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id FROM ds WHERE "), __cond_0, __sqlbundle_Literal(" AND ds.a_id = ?")}}

	var __values []any
	if !d_alias.isnull() {
		__cond_0.Null = false
		__values = append(__values, d_alias.value())
	}
	__values = append(__values, d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if err != nil {
		return (*D)(nil), obj.makeErr(err)
	}
	return d, nil

}

func (obj *spannerImpl) Paged_D_By_AId(ctx context.Context,
	d_a_id D_AId_Field,
	limit int, start *Paged_D_By_AId_Continuation) (
	rows []*D, next *Paged_D_By_AId_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? AND ds.pk > ? ORDER BY ds.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id, ds.pk FROM ds WHERE ds.a_id = ? ORDER BY ds.pk LIMIT ?")

	var __values []any
	__values = append(__values, d_a_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values,
			start._value_pk,
			limit,
		)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_D_By_AId_Continuation
	__continuation._set = true

	for __rows.Next() {
		d := &D{}
		err = __rows.Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, d)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Get_A_By_Pk(ctx context.Context,
	a_pk A_Pk_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as WHERE as.pk = ?")

	var __values []any
	__values = append(__values, a_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *spannerImpl) Get_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *spannerImpl) Get_A_By_A_Name_And_B_Id(ctx context.Context,
	a_name A_Name_Field,
	b_id B_Id_Field) (
	a *A, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.name = ? AND bs.id = ?")

	var __values []any
	__values = append(__values, a_name.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if err != nil {
		return (*A)(nil), obj.makeErr(err)
	}
	return a, nil

}

func (obj *spannerImpl) Paged_A_By_B_Id(ctx context.Context,
	b_id B_Id_Field,
	limit int, start *Paged_A_By_B_Id_Continuation) (
	rows []*A, next *Paged_A_By_B_Id_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? AND as.pk > ? ORDER BY as.pk LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT as.pk, as.ctime, as.mtime, as.id, as.name, as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE bs.id = ? ORDER BY as.pk LIMIT ?")

	var __values []any
	__values = append(__values, b_id.value())

	var __stmt string
	if start != nil && start._set {
		__values = append(__values,
			start._value_pk,
			limit,
		)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_A_By_B_Id_Continuation
	__continuation._set = true

	for __rows.Next() {
		a := &A{}
		err = __rows.Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name, &__continuation._value_pk)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, a)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Get_C_By_Id(ctx context.Context,
	c_id C_Id_Field) (
	c *C, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT cs.pk, cs.id, cs.b_pk FROM cs WHERE cs.id = ?")

	var __values []any
	__values = append(__values, c_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	c = &C{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&c.Pk, &c.Id, &c.BPk)
	if err != nil {
		return (*C)(nil), obj.makeErr(err)
	}
	return c, nil

}

func (obj *spannerImpl) Get_B_By_Pk(ctx context.Context,
	b_pk B_Pk_Field) (
	b *B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.pk = ?")

	var __values []any
	__values = append(__values, b_pk.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if err != nil {
		return (*B)(nil), obj.makeErr(err)
	}
	return b, nil

}

func (obj *spannerImpl) All_B_By_Data(ctx context.Context,
	b_data B_Data_Field) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs WHERE bs.data = ?")

	var __values []any
	__values = append(__values, b_data.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *spannerImpl) All_B(ctx context.Context) (
	rows []*B, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bs.pk, bs.id, bs.data FROM bs")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		b := &B{}
		err = __rows.Scan(&b.Pk, &b.Id, &b.Data)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, b)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *spannerImpl) All_Foo(ctx context.Context) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *spannerImpl) Count_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *spannerImpl) Has_Foo(ctx context.Context) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos )")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *spannerImpl) Limited_Foo(ctx context.Context,
	limit int, offset int64) (
	rows []*Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos LIMIT ? OFFSET ?")

	var __values []any

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *spannerImpl) Paged_Foo(ctx context.Context,
	limit int, start *Paged_Foo_Continuation) (
	rows []*Foo, next *Paged_Foo_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos WHERE foos.id > ? ORDER BY foos.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json, foos.id FROM foos ORDER BY foos.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values,
			start._value_id,
			limit,
		)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_Foo_Continuation
	__continuation._set = true

	for __rows.Next() {
		foo := &Foo{}
		err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson), &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, foo)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Count_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT COUNT(*) FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&count)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *spannerImpl) Has_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	has bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT EXISTS( SELECT 1 FROM foos WHERE foos.id = ? )")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&has)
	if err != nil {
		return false, obj.makeErr(err)
	}
	return has, nil

}

func (obj *spannerImpl) Find_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err == sql.ErrNoRows {
		return (*Foo)(nil), nil
	}
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *spannerImpl) Get_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ?")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return (*Foo)(nil), obj.makeErr(err)
	}
	return foo, nil

}

func (obj *spannerImpl) First_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.id = ? LIMIT 1 OFFSET 0")

	var __values []any
	__values = append(__values, foo_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) All_Foo_Bool_Foo_Int(ctx context.Context) (
	rows []*Bool_Int_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.bool, foos.int FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Bool_Int_Row{}
		err = __rows.Scan(&row.Bool, &row.Int)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *spannerImpl) First_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field) (
	foo *Foo, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" LIMIT 1 OFFSET 0")}}

	var __values []any
	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__values = append(__values, foo_null_int.value())
	}
	__values = append(__values, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__values = append(__values, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__values = append(__values, foo_null_uint.value())
	}
	__values = append(__values, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__values = append(__values, foo_null_uint64_not.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_Int_Equal_Number(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.int = 3 LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Int_Equal_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_NullInt_Is_Null(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_int is NULL LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullInt_Is_Null")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_String_Equal_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = 'boo' LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_Lower_String(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = ? LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_Lower_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE lower(foos.string) = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Lower_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_String_Equal_Lower(ctx context.Context,
	foo_string Foo_String_Field) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower(?) LIMIT 2")

	var __values []any
	__values = append(__values, foo_string.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_String_Equal_Lower_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.string = lower('BOO') LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_String_Equal_Lower_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_Bool_Equal_True(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.bool = true LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_Bool_Equal_True")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_By_NullBool_Equal_False(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos WHERE foos.null_bool = false LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_By_NullBool_Equal_False")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_OrderBy_Asc_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos ORDER BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_OrderBy_Asc_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Find_Foo_GroupBy_String(ctx context.Context) (
	foo *Foo, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json FROM foos GROUP BY foos.string LIMIT 2")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	foo = &Foo{}
	err = __rows.Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("Foo_GroupBy_String")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return foo, nil

}

func (obj *spannerImpl) Update_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field,
	update D_Update_Fields) (
	d *D, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE ds SET "), __sets, __sqlbundle_Literal(" WHERE ds.id = ? AND ds.a_id = ? THEN RETURN ds.pk, ds.id, ds.alias, ds.date, ds.e_id, ds.a_id")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Alias._set {
		__values = append(__values, update.Alias.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("alias = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, d_id.value(), d_a_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	d = &D{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&d.Pk, &d.Id, &d.Alias, &d.Date, &d.EId, &d.AId)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return d, nil
}

func (obj *spannerImpl) Update_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field,
	update A_Update_Fields) (
	a *A, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE as SET "), __sets, __sqlbundle_Literal(" WHERE pk IN (SELECT pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?) THEN RETURN as.pk, as.ctime, as.mtime, as.id, as.name")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("mtime = ?"))

	__args = append(__args, a_id.value(), b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	a = &A{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&a.Pk, &a.Ctime, &a.Mtime, &a.Id, &a.Name)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return a, nil
}

func (obj *spannerImpl) Update_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	b *B, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ? THEN RETURN bs.pk, bs.id, bs.data")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	b = &B{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&b.Pk, &b.Id, &b.Data)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return b, nil
}

func (obj *spannerImpl) UpdateNoReturn_B_By_Id(ctx context.Context,
	b_id B_Id_Field,
	update B_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE bs SET "), __sets, __sqlbundle_Literal(" WHERE bs.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Data._set {
		__values = append(__values, update.Data.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("data = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return emptyUpdate()
	}

	__args = append(__args, b_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *spannerImpl) Update_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ? THEN RETURN foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}
	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}
	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}
	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}
	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}
	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}
	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}
	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}
	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}
	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}
	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}
	if update.Json._set {
		__values = append(__values, spannerConvertJSON(update.Json.value()))
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}
	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}
	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}
	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}
	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}
	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}
	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}
	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}
	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}
	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}
	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}
	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}
	if update.NullJson._set {
		__values = append(__values, spannerConvertJSON(update.NullJson.value()))
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *spannerImpl) UpdateNoReturn_Foo_By_Id(ctx context.Context,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	err error) {

	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE foos.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}
	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}
	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}
	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}
	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}
	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}
	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}
	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}
	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}
	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}
	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}
	if update.Json._set {
		__values = append(__values, spannerConvertJSON(update.Json.value()))
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}
	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}
	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}
	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}
	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}
	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}
	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}
	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}
	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}
	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}
	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}
	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}
	if update.NullJson._set {
		__values = append(__values, spannerConvertJSON(update.NullJson.value()))
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	_, err = obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return obj.makeErr(err)
	}
	return nil
}

func (obj *spannerImpl) Update_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not_And_Id(ctx context.Context,
	foo_null_int Foo_NullInt_Field,
	foo_int Foo_Int_Field,
	foo_null_int64_not Foo_NullInt64_Field,
	foo_null_uint Foo_NullUint_Field,
	foo_uint Foo_Uint_Field,
	foo_null_uint64_not Foo_NullUint64_Field,
	foo_id Foo_Id_Field,
	update Foo_Update_Fields) (
	foo *Foo, err error) {

	var __sets = &__sqlbundle_Hole{}
	var __cond_0 = &__sqlbundle_Condition{Left: "foos.null_int", Equal: true, Right: "?", Null: true}
	var __cond_1 = &__sqlbundle_Condition{Left: "foos.null_int64", Equal: false, Right: "?", Null: true}
	var __cond_2 = &__sqlbundle_Condition{Left: "foos.null_uint", Equal: true, Right: "?", Null: true}
	var __cond_3 = &__sqlbundle_Condition{Left: "foos.null_uint64", Equal: false, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE foos SET "), __sets, __sqlbundle_Literal(" WHERE "), __cond_0, __sqlbundle_Literal(" AND foos.int = ? AND "), __cond_1, __sqlbundle_Literal(" AND "), __cond_2, __sqlbundle_Literal(" AND foos.uint = ? AND "), __cond_3, __sqlbundle_Literal(" AND foos.id = ? THEN RETURN foos.id, foos.int, foos.int64, foos.uint, foos.uint64, foos.float, foos.float64, foos.string, foos.blob, foos.timestamp, foos.utimestamp, foos.bool, foos.date, foos.json, foos.null_int, foos.null_int64, foos.null_uint, foos.null_uint64, foos.null_float, foos.null_float64, foos.null_string, foos.null_blob, foos.null_timestamp, foos.null_utimestamp, foos.null_bool, foos.null_date, foos.null_json")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []any
	var __args []any

	if update.Int._set {
		__values = append(__values, update.Int.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int = ?"))
	}
	if update.Int64._set {
		__values = append(__values, update.Int64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("int64 = ?"))
	}
	if update.Uint._set {
		__values = append(__values, update.Uint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint = ?"))
	}
	if update.Uint64._set {
		__values = append(__values, update.Uint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uint64 = ?"))
	}
	if update.Float._set {
		__values = append(__values, update.Float.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float = ?"))
	}
	if update.Float64._set {
		__values = append(__values, update.Float64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("float64 = ?"))
	}
	if update.String._set {
		__values = append(__values, update.String.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("string = ?"))
	}
	if update.Blob._set {
		__values = append(__values, update.Blob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("blob = ?"))
	}
	if update.Timestamp._set {
		__values = append(__values, update.Timestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("timestamp = ?"))
	}
	if update.Bool._set {
		__values = append(__values, update.Bool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("bool = ?"))
	}
	if update.Date._set {
		__values = append(__values, update.Date.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("date = ?"))
	}
	if update.Json._set {
		__values = append(__values, spannerConvertJSON(update.Json.value()))
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("json = ?"))
	}
	if update.NullInt._set {
		__values = append(__values, update.NullInt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int = ?"))
	}
	if update.NullInt64._set {
		__values = append(__values, update.NullInt64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_int64 = ?"))
	}
	if update.NullUint._set {
		__values = append(__values, update.NullUint.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint = ?"))
	}
	if update.NullUint64._set {
		__values = append(__values, update.NullUint64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_uint64 = ?"))
	}
	if update.NullFloat._set {
		__values = append(__values, update.NullFloat.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float = ?"))
	}
	if update.NullFloat64._set {
		__values = append(__values, update.NullFloat64.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_float64 = ?"))
	}
	if update.NullString._set {
		__values = append(__values, update.NullString.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_string = ?"))
	}
	if update.NullBlob._set {
		__values = append(__values, update.NullBlob.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_blob = ?"))
	}
	if update.NullTimestamp._set {
		__values = append(__values, update.NullTimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_timestamp = ?"))
	}
	if update.NullUtimestamp._set {
		__values = append(__values, update.NullUtimestamp.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_utimestamp = ?"))
	}
	if update.NullBool._set {
		__values = append(__values, update.NullBool.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_bool = ?"))
	}
	if update.NullJson._set {
		__values = append(__values, spannerConvertJSON(update.NullJson.value()))
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_json = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now.UTC())
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("utimestamp = ?"))

	__values = append(__values, (*time.Time)(nil))
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("null_date = ?"))

	if !foo_null_int.isnull() {
		__cond_0.Null = false
		__args = append(__args, foo_null_int.value())
	}
	__args = append(__args, foo_int.value())
	if !foo_null_int64_not.isnull() {
		__cond_1.Null = false
		__args = append(__args, foo_null_int64_not.value())
	}
	if !foo_null_uint.isnull() {
		__cond_2.Null = false
		__args = append(__args, foo_null_uint.value())
	}
	__args = append(__args, foo_uint.value())
	if !foo_null_uint64_not.isnull() {
		__cond_3.Null = false
		__args = append(__args, foo_null_uint64_not.value())
	}
	__args = append(__args, foo_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	foo = &Foo{}
	__d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		__d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(txErr, sql.ErrTxDone) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = __d.QueryRowContext(ctx, __stmt, __values...).Scan(&foo.Id, &foo.Int, &foo.Int64, &foo.Uint, &foo.Uint64, &foo.Float, &foo.Float64, &foo.String, &foo.Blob, &foo.Timestamp, &foo.Utimestamp, &foo.Bool, &foo.Date, spannerConvertJSON(&foo.Json), &foo.NullInt, &foo.NullInt64, &foo.NullUint, &foo.NullUint64, &foo.NullFloat, &foo.NullFloat64, &foo.NullString, &foo.NullBlob, &foo.NullTimestamp, &foo.NullUtimestamp, &foo.NullBool, &foo.NullDate, spannerConvertJSON(&foo.NullJson))
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return foo, nil
}

func (obj *spannerImpl) Delete_E_By_Id_And_AId(ctx context.Context,
	e_id E_Id_Field,
	e_a_id E_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es WHERE es.id = ? AND es.a_id = ?")

	var __values []any
	__values = append(__values, e_id.value(), e_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *spannerImpl) Delete_E(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM es")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *spannerImpl) Delete_D_By_Id_And_AId(ctx context.Context,
	d_id D_Id_Field,
	d_a_id D_AId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM ds WHERE ds.id = ? AND ds.a_id = ?")

	var __values []any
	__values = append(__values, d_id.value(), d_a_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *spannerImpl) Delete_A_By_A_Id_And_B_Id(ctx context.Context,
	a_id A_Id_Field,
	b_id B_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM as WHERE as.pk IN (SELECT as.pk FROM as  JOIN a_bs ON as.pk = a_bs.a_pk  JOIN bs ON a_bs.b_pk = bs.pk WHERE as.id = ? AND bs.id = ?)")

	var __values []any
	__values = append(__values, a_id.value(), b_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *spannerImpl) Delete_Foo(ctx context.Context) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM foos")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.ExecContext(ctx, __stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (impl spannerImpl) isConstraintError(err error) (constraint string, ok bool) {
	return "", false
}

func (obj *spannerImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM ds;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM es;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM cs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM a_bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM foos;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM bs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM as;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Methods interface {
	All_B(ctx context.Context) (
		rows []*B, err error)

	All_B_By_Data(ctx context.Context,
		b_data B_Data_Field) (
		rows []*B, err error)

	All_Foo(ctx context.Context) (
		rows []*Foo, err error)

	All_Foo_Bool_Foo_Int(ctx context.Context) (
		rows []*Bool_Int_Row, err error)

	Count_Foo(ctx context.Context) (
		count int64, err error)

	Count_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field) (
		count int64, err error)

	CreateNoReturn_Foo(ctx context.Context,
		foo_int Foo_Int_Field,
		foo_int64 Foo_Int64_Field,
		foo_uint Foo_Uint_Field,
		foo_uint64 Foo_Uint64_Field,
		foo_float Foo_Float_Field,
		foo_float64 Foo_Float64_Field,
		foo_string Foo_String_Field,
		foo_blob Foo_Blob_Field,
		foo_bool Foo_Bool_Field,
		foo_date Foo_Date_Field,
		foo_json Foo_Json_Field,
		optional Foo_Create_Fields) (
		err error)

	Create_A(ctx context.Context,
		a_id A_Id_Field,
		a_name A_Name_Field) (
		a *A, err error)

	Create_AB(ctx context.Context,
		a_b_b_pk AB_BPk_Field,
		a_b_a_pk AB_APk_Field) (
		a_b *AB, err error)

	Create_B(ctx context.Context,
		b_id B_Id_Field,
		b_data B_Data_Field) (
		b *B, err error)

	Create_C(ctx context.Context,
		c_id C_Id_Field,
		c_b_pk C_BPk_Field) (
		c *C, err error)

	Create_D(ctx context.Context,
		d_id D_Id_Field,
		d_e_id D_EId_Field,
		d_a_id D_AId_Field,
		optional D_Create_Fields) (
		d *D, err error)

	Create_E(ctx context.Context,
		e_id E_Id_Field,
		e_a_id E_AId_Field) (
		e *E, err error)

	Create_Foo(ctx context.Context,
		foo_int Foo_Int_Field,
		foo_int64 Foo_Int64_Field,
		foo_uint Foo_Uint_Field,
		foo_uint64 Foo_Uint64_Field,
		foo_float Foo_Float_Field,
		foo_float64 Foo_Float64_Field,
		foo_string Foo_String_Field,
		foo_blob Foo_Blob_Field,
		foo_bool Foo_Bool_Field,
		foo_date Foo_Date_Field,
		foo_json Foo_Json_Field,
		optional Foo_Create_Fields) (
		foo *Foo, err error)

	Delete_A_By_A_Id_And_B_Id(ctx context.Context,
		a_id A_Id_Field,
		b_id B_Id_Field) (
		deleted bool, err error)

	Delete_D_By_Id_And_AId(ctx context.Context,
		d_id D_Id_Field,
		d_a_id D_AId_Field) (
		deleted bool, err error)

	Delete_E(ctx context.Context) (
		count int64, err error)

	Delete_E_By_Id_And_AId(ctx context.Context,
		e_id E_Id_Field,
		e_a_id E_AId_Field) (
		deleted bool, err error)

	Delete_Foo(ctx context.Context) (
		count int64, err error)

	Find_Foo_By_Bool_Equal_True(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field) (
		foo *Foo, err error)

	Find_Foo_By_Int_Equal_Number(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_By_Lower_String(ctx context.Context,
		foo_string Foo_String_Field) (
		foo *Foo, err error)

	Find_Foo_By_Lower_String_Equal_Lower(ctx context.Context,
		foo_string Foo_String_Field) (
		foo *Foo, err error)

	Find_Foo_By_NullBool_Equal_False(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_By_NullInt_Is_Null(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_By_String_Equal_Lower(ctx context.Context,
		foo_string Foo_String_Field) (
		foo *Foo, err error)

	Find_Foo_By_String_Equal_Lower_String(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_By_String_Equal_String(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_GroupBy_String(ctx context.Context) (
		foo *Foo, err error)

	Find_Foo_OrderBy_Asc_String(ctx context.Context) (
		foo *Foo, err error)

	First_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field) (
		foo *Foo, err error)

	First_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not(ctx context.Context,
		foo_null_int Foo_NullInt_Field,
		foo_int Foo_Int_Field,
		foo_null_int64_not Foo_NullInt64_Field,
		foo_null_uint Foo_NullUint_Field,
		foo_uint Foo_Uint_Field,
		foo_null_uint64_not Foo_NullUint64_Field) (
		foo *Foo, err error)

	Get_A_By_A_Id_And_B_Id(ctx context.Context,
		a_id A_Id_Field,
		b_id B_Id_Field) (
		a *A, err error)

	Get_A_By_A_Name_And_B_Id(ctx context.Context,
		a_name A_Name_Field,
		b_id B_Id_Field) (
		a *A, err error)

	Get_A_By_Pk(ctx context.Context,
		a_pk A_Pk_Field) (
		a *A, err error)

	Get_B_By_Pk(ctx context.Context,
		b_pk B_Pk_Field) (
		b *B, err error)

	Get_C_By_Id(ctx context.Context,
		c_id C_Id_Field) (
		c *C, err error)

	Get_D_By_Alias_And_AId(ctx context.Context,
		d_alias D_Alias_Field,
		d_a_id D_AId_Field) (
		d *D, err error)

	Get_D_By_Id(ctx context.Context,
		d_id D_Id_Field) (
		d *D, err error)

	Get_D_By_Id_And_AId(ctx context.Context,
		d_id D_Id_Field,
		d_a_id D_AId_Field) (
		d *D, err error)

	Get_E_By_Id_And_AId(ctx context.Context,
		e_id E_Id_Field,
		e_a_id E_AId_Field) (
		e *E, err error)

	Get_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field) (
		foo *Foo, err error)

	Has_E_By_Id_And_AId(ctx context.Context,
		e_id E_Id_Field,
		e_a_id E_AId_Field) (
		has bool, err error)

	Has_Foo(ctx context.Context) (
		has bool, err error)

	Has_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field) (
		has bool, err error)

	Limited_Foo(ctx context.Context,
		limit int, offset int64) (
		rows []*Foo, err error)

	Paged_A_By_B_Id(ctx context.Context,
		b_id B_Id_Field,
		limit int, start *Paged_A_By_B_Id_Continuation) (
		rows []*A, next *Paged_A_By_B_Id_Continuation, err error)

	Paged_D_By_AId(ctx context.Context,
		d_a_id D_AId_Field,
		limit int, start *Paged_D_By_AId_Continuation) (
		rows []*D, next *Paged_D_By_AId_Continuation, err error)

	Paged_E_By_AId(ctx context.Context,
		e_a_id E_AId_Field,
		limit int, start *Paged_E_By_AId_Continuation) (
		rows []*E, next *Paged_E_By_AId_Continuation, err error)

	Paged_Foo(ctx context.Context,
		limit int, start *Paged_Foo_Continuation) (
		rows []*Foo, next *Paged_Foo_Continuation, err error)

	RawCreateNoReturn_Foo(ctx context.Context,
		raw_foo *Foo) (
		err error)

	RawCreate_D(ctx context.Context,
		raw_d *D) (
		d *D, err error)

	RawCreate_Foo(ctx context.Context,
		raw_foo *Foo) (
		foo *Foo, err error)

	UpdateNoReturn_B_By_Id(ctx context.Context,
		b_id B_Id_Field,
		update B_Update_Fields) (
		err error)

	UpdateNoReturn_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field,
		update Foo_Update_Fields) (
		err error)

	Update_A_By_A_Id_And_B_Id(ctx context.Context,
		a_id A_Id_Field,
		b_id B_Id_Field,
		update A_Update_Fields) (
		a *A, err error)

	Update_B_By_Id(ctx context.Context,
		b_id B_Id_Field,
		update B_Update_Fields) (
		b *B, err error)

	Update_D_By_Id_And_AId(ctx context.Context,
		d_id D_Id_Field,
		d_a_id D_AId_Field,
		update D_Update_Fields) (
		d *D, err error)

	Update_Foo_By_Id(ctx context.Context,
		foo_id Foo_Id_Field,
		update Foo_Update_Fields) (
		foo *Foo, err error)

	Update_Foo_By_NullInt_And_Int_And_NullInt64_Not_And_NullUint_And_Uint_And_NullUint64_Not_And_Id(ctx context.Context,
		foo_null_int Foo_NullInt_Field,
		foo_int Foo_Int_Field,
		foo_null_int64_not Foo_NullInt64_Field,
		foo_null_uint Foo_NullUint_Field,
		foo_uint Foo_Uint_Field,
		foo_null_uint64_not Foo_NullUint64_Field,
		foo_id Foo_Id_Field,
		update Foo_Update_Fields) (
		foo *Foo, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() []string
	DropSchema() []string

	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

var sqlite3DriverName = func() string {
	var id [16]byte
	_, _ = rand.Read(id[:])
	return fmt.Sprintf("sqlite3_%x", string(id[:]))
}()

func init() {
	sql.Register(sqlite3DriverName, &sqlite3.SQLiteDriver{
		ConnectHook: sqlite3SetupConn,
	})
}

// SQLite3JournalMode controls the journal_mode pragma for all new connections.
// Since it is read without a mutex, it must be changed to the value you want
// before any Open calls.
var SQLite3JournalMode = "WAL"

func sqlite3SetupConn(conn *sqlite3.SQLiteConn) (err error) {
	_, err = conn.Exec("PRAGMA foreign_keys = ON", nil)
	if err != nil {
		return makeErr(err)
	}
	_, err = conn.Exec("PRAGMA journal_mode = "+SQLite3JournalMode, nil)
	if err != nil {
		return makeErr(err)
	}
	return nil
}

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open(sqlite3DriverName, source)
}

func openpgx(source string) (*sql.DB, error) {
	return sql.Open("pgx", source)
}

func openpgxcockroach(source string) (*sql.DB, error) {
	// try first with "cockroach" as a driver in case someone has registered
	// some special stuff. if that fails, then try again with "pgx" as
	// the driver.
	db, err := sql.Open("cockroach", source)
	if err != nil {
		db, err = sql.Open("pgx", source)
	}
	return db, err
}

func openspanner(source string) (*sql.DB, error) {
	return sql.Open("spanner", strings.TrimPrefix(source, "spanner://"))
}

func spannerConvertJSON(v any) any {
	if v == nil {
		return spanner.NullJSON{Value: nil, Valid: true}
	}
	if v, ok := v.([]byte); ok {
		return spanner.NullJSON{Value: v, Valid: true}
	}
	if v, ok := v.(*[]byte); ok {
		return &spannerJSON{data: v}
	}
	return v
}

type spannerJSON struct {
	data *[]byte
}

func (s *spannerJSON) Scan(input any) error {
	if input == nil {
		*s.data = nil
		return nil
	}
	if v, ok := input.(spanner.NullJSON); ok {
		if !v.Valid || v.Value == nil {
			*s.data = nil
			return nil
		}

		if str, ok := v.Value.(string); ok {
			bytesVal, err := base64.StdEncoding.DecodeString(str)
			if err != nil {
				return fmt.Errorf("expected base64 from spanner: %w", err)
			}
			*s.data = bytesVal
			return nil
		}

		// "{}" gets returned back as a map[string]interface{} for some reason, so capture any other odd value
		// that comes back and try and marshal it via json.
		bytesVal, err := json.Marshal(v.Value)
		if err != nil {
			return fmt.Errorf("failed to marshal spanner.NullJSON value with type %T to json bytes: %w", v.Value, err)
		}
		*s.data = bytesVal

		return nil
	}
	return fmt.Errorf("unable to decode %T", input)
}
