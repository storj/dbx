// AUTOGENERATED BY storj.io/dbx
// DO NOT EDIT.

package paged_scalar

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	_ "cloud.google.com/go/spanner"
	"crypto/rand"
	sqldriver "database/sql/driver"
	_ "github.com/googleapis/go-sql-spanner"
	"github.com/jackc/pgx/v5/pgconn"
	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/mattn/go-sqlite3"
	"math"
)

// Prevent conditional imports from causing build failures.
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...any)

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...any) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func (e *Error) Unwrap() error {
	return e.Err
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	var e *Error
	if errors.As(err, &e) {
		return wrapErr(e)
	}
	e = &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	case "pgx":
		sql_db, err = openpgx(source)
	case "pgxcockroach":
		sql_db, err = openpgxcockroach(source)
	case "spanner":
		sql_db, err = openspanner(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			_ = sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	case "pgx":
		db.dbMethods = newpgx(db)
	case "pgxcockroach":
		db.dbMethods = newpgxcockroach(db)
	case "spanner":
		db.dbMethods = newspanner(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
	txn     bool
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...any) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() []string {
	return []string{

		`CREATE TABLE data_blobs (
	id BLOB NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_dates (
	id DATE NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_floats (
	id REAL NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_float64s (
	id REAL NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_ints (
	id INTEGER NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_int64s (
	id INTEGER NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_jsons (
	id TEXT NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_serials (
	id INTEGER NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_serial64s (
	id INTEGER NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_texts (
	id TEXT NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_timestamps (
	id TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_uints (
	id INTEGER NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_uint64s (
	id INTEGER NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_utimestamps (
	id TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
)`,
	}
}

func (obj *sqlite3DB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS data_utimestamps`,

		`DROP TABLE IF EXISTS data_uint64s`,

		`DROP TABLE IF EXISTS data_uints`,

		`DROP TABLE IF EXISTS data_timestamps`,

		`DROP TABLE IF EXISTS data_texts`,

		`DROP TABLE IF EXISTS data_serial64s`,

		`DROP TABLE IF EXISTS data_serials`,

		`DROP TABLE IF EXISTS data_jsons`,

		`DROP TABLE IF EXISTS data_int64s`,

		`DROP TABLE IF EXISTS data_ints`,

		`DROP TABLE IF EXISTS data_float64s`,

		`DROP TABLE IF EXISTS data_floats`,

		`DROP TABLE IF EXISTS data_dates`,

		`DROP TABLE IF EXISTS data_blobs`,
	}
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pgxImpl struct {
	db      *DB
	dialect __sqlbundle_pgx
	driver  driver
	txn     bool
}

func (obj *pgxImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *pgxImpl) logStmt(stmt string, args ...any) {
	pgxLogStmt(stmt, args...)
}

func (obj *pgxImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type pgxDB struct {
	db *DB
	*pgxImpl
}

func newpgx(db *DB) *pgxDB {
	return &pgxDB{
		db: db,
		pgxImpl: &pgxImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *pgxDB) Schema() []string {
	return []string{

		`CREATE TABLE data_blobs (
	id bytea NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_dates (
	id date NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_floats (
	id real NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_float64s (
	id double precision NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_ints (
	id integer NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_int64s (
	id bigint NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_jsons (
	id jsonb NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_serials (
	id serial NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_serial64s (
	id bigserial NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_texts (
	id text NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_timestamps (
	id timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_uints (
	id integer NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_uint64s (
	id bigint NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_utimestamps (
	id timestamp NOT NULL,
	PRIMARY KEY ( id )
)`,
	}
}

func (obj *pgxDB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS data_utimestamps`,

		`DROP TABLE IF EXISTS data_uint64s`,

		`DROP TABLE IF EXISTS data_uints`,

		`DROP TABLE IF EXISTS data_timestamps`,

		`DROP TABLE IF EXISTS data_texts`,

		`DROP TABLE IF EXISTS data_serial64s`,

		`DROP TABLE IF EXISTS data_serials`,

		`DROP TABLE IF EXISTS data_jsons`,

		`DROP TABLE IF EXISTS data_int64s`,

		`DROP TABLE IF EXISTS data_ints`,

		`DROP TABLE IF EXISTS data_float64s`,

		`DROP TABLE IF EXISTS data_floats`,

		`DROP TABLE IF EXISTS data_dates`,

		`DROP TABLE IF EXISTS data_blobs`,
	}
}

func (obj *pgxDB) wrapTx(tx *sql.Tx) txMethods {
	return &pgxTx{
		dialectTx: dialectTx{tx: tx},
		pgxImpl: &pgxImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type pgxTx struct {
	dialectTx
	*pgxImpl
}

func pgxLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pgxcockroachImpl struct {
	db      *DB
	dialect __sqlbundle_pgxcockroach
	driver  driver
	txn     bool
}

func (obj *pgxcockroachImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *pgxcockroachImpl) logStmt(stmt string, args ...any) {
	pgxcockroachLogStmt(stmt, args...)
}

func (obj *pgxcockroachImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type pgxcockroachDB struct {
	db *DB
	*pgxcockroachImpl
}

func newpgxcockroach(db *DB) *pgxcockroachDB {
	return &pgxcockroachDB{
		db: db,
		pgxcockroachImpl: &pgxcockroachImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *pgxcockroachDB) Schema() []string {
	return []string{

		`CREATE TABLE data_blobs (
	id bytea NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_dates (
	id date NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_floats (
	id real NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_float64s (
	id double precision NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_ints (
	id integer NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_int64s (
	id bigint NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_jsons (
	id jsonb NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_serials (
	id serial NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_serial64s (
	id bigserial NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_texts (
	id text NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_timestamps (
	id timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_uints (
	id integer NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_uint64s (
	id bigint NOT NULL,
	PRIMARY KEY ( id )
)`,

		`CREATE TABLE data_utimestamps (
	id timestamp NOT NULL,
	PRIMARY KEY ( id )
)`,
	}
}

func (obj *pgxcockroachDB) DropSchema() []string {
	return []string{

		`DROP TABLE IF EXISTS data_utimestamps`,

		`DROP TABLE IF EXISTS data_uint64s`,

		`DROP TABLE IF EXISTS data_uints`,

		`DROP TABLE IF EXISTS data_timestamps`,

		`DROP TABLE IF EXISTS data_texts`,

		`DROP TABLE IF EXISTS data_serial64s`,

		`DROP TABLE IF EXISTS data_serials`,

		`DROP TABLE IF EXISTS data_jsons`,

		`DROP TABLE IF EXISTS data_int64s`,

		`DROP TABLE IF EXISTS data_ints`,

		`DROP TABLE IF EXISTS data_float64s`,

		`DROP TABLE IF EXISTS data_floats`,

		`DROP TABLE IF EXISTS data_dates`,

		`DROP TABLE IF EXISTS data_blobs`,
	}
}

func (obj *pgxcockroachDB) wrapTx(tx *sql.Tx) txMethods {
	return &pgxcockroachTx{
		dialectTx: dialectTx{tx: tx},
		pgxcockroachImpl: &pgxcockroachImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type pgxcockroachTx struct {
	dialectTx
	*pgxcockroachImpl
}

func pgxcockroachLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type spannerImpl struct {
	db      *DB
	dialect __sqlbundle_spanner
	driver  driver
	txn     bool
}

func (obj *spannerImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *spannerImpl) logStmt(stmt string, args ...any) {
	spannerLogStmt(stmt, args...)
}

func (obj *spannerImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type spannerDB struct {
	db *DB
	*spannerImpl
}

func newspanner(db *DB) *spannerDB {
	return &spannerDB{
		db: db,
		spannerImpl: &spannerImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *spannerDB) Schema() []string {
	return []string{

		`CREATE TABLE data_blobs (
	id BYTES(MAX) NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_dates (
	id TIMESTAMP NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_floats (
	id FLOAT32 NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_float64s (
	id FLOAT64 NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_ints (
	id INT64 NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_int64s (
	id INT64 NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_jsons (
	id JSON NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE SEQUENCE data_serials_id OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE data_serials (
	id INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE data_serials_id))
) PRIMARY KEY ( id )`,

		`CREATE SEQUENCE data_serial64s_id OPTIONS (sequence_kind='bit_reversed_positive')`,

		`CREATE TABLE data_serial64s (
	id INT64 NOT NULL DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE data_serial64s_id))
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_texts (
	id STRING(MAX) NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_timestamps (
	id TIMESTAMP NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_uints (
	id INT64 NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_uint64s (
	id INT64 NOT NULL
) PRIMARY KEY ( id )`,

		`CREATE TABLE data_utimestamps (
	id TIMESTAMP NOT NULL
) PRIMARY KEY ( id )`,
	}
}

func (obj *spannerDB) DropSchema() []string {
	return []string{

		`ALTER TABLE  data_utimestamps ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_utimestamps_id`,

		`DROP TABLE IF EXISTS data_utimestamps`,

		`ALTER TABLE  data_uint64s ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_uint64s_id`,

		`DROP TABLE IF EXISTS data_uint64s`,

		`ALTER TABLE  data_uints ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_uints_id`,

		`DROP TABLE IF EXISTS data_uints`,

		`ALTER TABLE  data_timestamps ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_timestamps_id`,

		`DROP TABLE IF EXISTS data_timestamps`,

		`ALTER TABLE  data_texts ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_texts_id`,

		`DROP TABLE IF EXISTS data_texts`,

		`ALTER TABLE  data_serial64s ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_serial64s_id`,

		`DROP TABLE IF EXISTS data_serial64s`,

		`ALTER TABLE  data_serials ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_serials_id`,

		`DROP TABLE IF EXISTS data_serials`,

		`ALTER TABLE  data_jsons ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_jsons_id`,

		`DROP TABLE IF EXISTS data_jsons`,

		`ALTER TABLE  data_int64s ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_int64s_id`,

		`DROP TABLE IF EXISTS data_int64s`,

		`ALTER TABLE  data_ints ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_ints_id`,

		`DROP TABLE IF EXISTS data_ints`,

		`ALTER TABLE  data_float64s ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_float64s_id`,

		`DROP TABLE IF EXISTS data_float64s`,

		`ALTER TABLE  data_floats ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_floats_id`,

		`DROP TABLE IF EXISTS data_floats`,

		`ALTER TABLE  data_dates ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_dates_id`,

		`DROP TABLE IF EXISTS data_dates`,

		`ALTER TABLE  data_blobs ALTER id SET DEFAULT (null)`,

		`DROP SEQUENCE IF EXISTS data_blobs_id`,

		`DROP TABLE IF EXISTS data_blobs`,
	}
}

func (obj *spannerDB) wrapTx(tx *sql.Tx) txMethods {
	return &spannerTx{
		dialectTx: dialectTx{tx: tx},
		spannerImpl: &spannerImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type spannerTx struct {
	dialectTx
	*spannerImpl
}

func spannerLogStmt(stmt string, args ...any) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []any

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type DataBlob struct {
	Id []byte
}

func (DataBlob) _Table() string { return "data_blobs" }

type DataBlob_Update_Fields struct {
}

type DataBlob_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func DataBlob_Id(v []byte) DataBlob_Id_Field {
	return DataBlob_Id_Field{_set: true, _value: v}
}

func (f DataBlob_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataDate struct {
	Id time.Time
}

func (DataDate) _Table() string { return "data_dates" }

type DataDate_Update_Fields struct {
}

type DataDate_Id_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func DataDate_Id(v time.Time) DataDate_Id_Field {
	v = toDate(v)
	return DataDate_Id_Field{_set: true, _value: v}
}

func (f DataDate_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataFloat struct {
	Id float32
}

func (DataFloat) _Table() string { return "data_floats" }

type DataFloat_Update_Fields struct {
}

type DataFloat_Id_Field struct {
	_set   bool
	_null  bool
	_value float32
}

func DataFloat_Id(v float32) DataFloat_Id_Field {
	return DataFloat_Id_Field{_set: true, _value: v}
}

func (f DataFloat_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataFloat64 struct {
	Id float64
}

func (DataFloat64) _Table() string { return "data_float64s" }

type DataFloat64_Update_Fields struct {
}

type DataFloat64_Id_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func DataFloat64_Id(v float64) DataFloat64_Id_Field {
	return DataFloat64_Id_Field{_set: true, _value: v}
}

func (f DataFloat64_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataInt struct {
	Id int
}

func (DataInt) _Table() string { return "data_ints" }

type DataInt_Update_Fields struct {
}

type DataInt_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func DataInt_Id(v int) DataInt_Id_Field {
	return DataInt_Id_Field{_set: true, _value: v}
}

func (f DataInt_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataInt64 struct {
	Id int64
}

func (DataInt64) _Table() string { return "data_int64s" }

type DataInt64_Update_Fields struct {
}

type DataInt64_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func DataInt64_Id(v int64) DataInt64_Id_Field {
	return DataInt64_Id_Field{_set: true, _value: v}
}

func (f DataInt64_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataJson struct {
	Id []byte
}

func (DataJson) _Table() string { return "data_jsons" }

type DataJson_Update_Fields struct {
}

type DataJson_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func DataJson_Id(v []byte) DataJson_Id_Field {
	return DataJson_Id_Field{_set: true, _value: v}
}

func (f DataJson_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataSerial struct {
	Id int
}

func (DataSerial) _Table() string { return "data_serials" }

type DataSerial_Update_Fields struct {
}

type DataSerial_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func DataSerial_Id(v int) DataSerial_Id_Field {
	return DataSerial_Id_Field{_set: true, _value: v}
}

func (f DataSerial_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataSerial64 struct {
	Id int64
}

func (DataSerial64) _Table() string { return "data_serial64s" }

type DataSerial64_Update_Fields struct {
}

type DataSerial64_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func DataSerial64_Id(v int64) DataSerial64_Id_Field {
	return DataSerial64_Id_Field{_set: true, _value: v}
}

func (f DataSerial64_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataText struct {
	Id string
}

func (DataText) _Table() string { return "data_texts" }

type DataText_Update_Fields struct {
}

type DataText_Id_Field struct {
	_set   bool
	_null  bool
	_value string
}

func DataText_Id(v string) DataText_Id_Field {
	return DataText_Id_Field{_set: true, _value: v}
}

func (f DataText_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataTimestamp struct {
	Id time.Time
}

func (DataTimestamp) _Table() string { return "data_timestamps" }

type DataTimestamp_Update_Fields struct {
}

type DataTimestamp_Id_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func DataTimestamp_Id(v time.Time) DataTimestamp_Id_Field {
	return DataTimestamp_Id_Field{_set: true, _value: v}
}

func (f DataTimestamp_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataUint struct {
	Id uint
}

func (DataUint) _Table() string { return "data_uints" }

type DataUint_Update_Fields struct {
}

type DataUint_Id_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func DataUint_Id(v uint) DataUint_Id_Field {
	return DataUint_Id_Field{_set: true, _value: v}
}

func (f DataUint_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataUint64 struct {
	Id uint64
}

func (DataUint64) _Table() string { return "data_uint64s" }

type DataUint64_Update_Fields struct {
}

type DataUint64_Id_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func DataUint64_Id(v uint64) DataUint64_Id_Field {
	return DataUint64_Id_Field{_set: true, _value: v}
}

func (f DataUint64_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

type DataUtimestamp struct {
	Id time.Time
}

func (DataUtimestamp) _Table() string { return "data_utimestamps" }

type DataUtimestamp_Update_Fields struct {
}

type DataUtimestamp_Id_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func DataUtimestamp_Id(v time.Time) DataUtimestamp_Id_Field {
	v = toUTC(v)
	return DataUtimestamp_Id_Field{_set: true, _value: v}
}

func (f DataUtimestamp_Id_Field) value() any {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	// Rebind gives the opportunity to rewrite provided SQL into a SQL dialect.
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_RenderAll(dialect __sqlbundle_Dialect, sqls []__sqlbundle_SQL, ops ...__sqlbundle_RenderOp) []string {
	var rs []string
	for _, sql := range sqls {
		rs = append(rs, __sqlbundle_Render(dialect, sql, ops...))
	}
	return rs
}

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_cockroach struct{}

func (p __sqlbundle_cockroach) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgx struct{}

func (p __sqlbundle_pgx) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgxcockroach struct{}

func (p __sqlbundle_pgxcockroach) Rebind(sql string) string {
	return __sqlbundle_postgres{}.Rebind(sql)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_spanner struct{}

func (p __sqlbundle_spanner) Rebind(sql string) string {
	return sql
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime or possibly embed time
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string {
	if h.SQL == nil {
		return ""
	}
	return h.SQL.Render()
}

//
// end runtime support for building sql statements
//

type Paged_DataBlob_Continuation struct {
	_value_id []byte
	_set      bool
}

type Paged_DataDate_Continuation struct {
	_value_id time.Time
	_set      bool
}

type Paged_DataFloat64_Continuation struct {
	_value_id float64
	_set      bool
}

type Paged_DataFloat_Continuation struct {
	_value_id float32
	_set      bool
}

type Paged_DataInt64_Continuation struct {
	_value_id int64
	_set      bool
}

type Paged_DataInt_Continuation struct {
	_value_id int
	_set      bool
}

type Paged_DataJson_Continuation struct {
	_value_id []byte
	_set      bool
}

type Paged_DataSerial64_Continuation struct {
	_value_id int64
	_set      bool
}

type Paged_DataSerial_Continuation struct {
	_value_id int
	_set      bool
}

type Paged_DataText_Continuation struct {
	_value_id string
	_set      bool
}

type Paged_DataTimestamp_Continuation struct {
	_value_id time.Time
	_set      bool
}

type Paged_DataUint64_Continuation struct {
	_value_id uint64
	_set      bool
}

type Paged_DataUint_Continuation struct {
	_value_id uint
	_set      bool
}

type Paged_DataUtimestamp_Continuation struct {
	_value_id time.Time
	_set      bool
}

func (obj *sqlite3Impl) Create_DataBlob(ctx context.Context,
	data_blob_id DataBlob_Id_Field) (
	data_blob *DataBlob, err error) {
	__id_val := data_blob_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_blobs ( id ) VALUES ( ? ) RETURNING data_blobs.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_blob = &DataBlob{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_blob.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_blob, nil

}

func (obj *sqlite3Impl) Create_DataDate(ctx context.Context,
	data_date_id DataDate_Id_Field) (
	data_date *DataDate, err error) {
	__id_val := data_date_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_dates ( id ) VALUES ( ? ) RETURNING data_dates.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_date = &DataDate{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_date.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_date, nil

}

func (obj *sqlite3Impl) Create_DataFloat(ctx context.Context,
	data_float_id DataFloat_Id_Field) (
	data_float *DataFloat, err error) {
	__id_val := data_float_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_floats ( id ) VALUES ( ? ) RETURNING data_floats.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float = &DataFloat{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float, nil

}

func (obj *sqlite3Impl) Create_DataFloat64(ctx context.Context,
	data_float64_id DataFloat64_Id_Field) (
	data_float64 *DataFloat64, err error) {
	__id_val := data_float64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_float64s ( id ) VALUES ( ? ) RETURNING data_float64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float64 = &DataFloat64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float64, nil

}

func (obj *sqlite3Impl) Create_DataInt(ctx context.Context,
	data_int_id DataInt_Id_Field) (
	data_int *DataInt, err error) {
	__id_val := data_int_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_ints ( id ) VALUES ( ? ) RETURNING data_ints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int = &DataInt{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int, nil

}

func (obj *sqlite3Impl) Create_DataInt64(ctx context.Context,
	data_int64_id DataInt64_Id_Field) (
	data_int64 *DataInt64, err error) {
	__id_val := data_int64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_int64s ( id ) VALUES ( ? ) RETURNING data_int64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int64 = &DataInt64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int64, nil

}

func (obj *sqlite3Impl) Create_DataJson(ctx context.Context,
	data_json_id DataJson_Id_Field) (
	data_json *DataJson, err error) {
	__id_val := data_json_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_jsons ( id ) VALUES ( ? ) RETURNING data_jsons.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_json = &DataJson{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_json.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_json, nil

}

func (obj *sqlite3Impl) Create_DataSerial(ctx context.Context) (
	data_serial *DataSerial, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serials DEFAULT VALUES RETURNING data_serials.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial = &DataSerial{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial, nil

}

func (obj *sqlite3Impl) Create_DataSerial64(ctx context.Context) (
	data_serial64 *DataSerial64, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serial64s DEFAULT VALUES RETURNING data_serial64s.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial64 = &DataSerial64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial64, nil

}

func (obj *sqlite3Impl) Create_DataText(ctx context.Context,
	data_text_id DataText_Id_Field) (
	data_text *DataText, err error) {
	__id_val := data_text_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_texts ( id ) VALUES ( ? ) RETURNING data_texts.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_text = &DataText{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_text.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_text, nil

}

func (obj *sqlite3Impl) Create_DataTimestamp(ctx context.Context,
	data_timestamp_id DataTimestamp_Id_Field) (
	data_timestamp *DataTimestamp, err error) {
	__id_val := data_timestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_timestamps ( id ) VALUES ( ? ) RETURNING data_timestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_timestamp = &DataTimestamp{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_timestamp.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_timestamp, nil

}

func (obj *sqlite3Impl) Create_DataUint(ctx context.Context,
	data_uint_id DataUint_Id_Field) (
	data_uint *DataUint, err error) {
	__id_val := data_uint_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uints ( id ) VALUES ( ? ) RETURNING data_uints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint = &DataUint{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint, nil

}

func (obj *sqlite3Impl) Create_DataUint64(ctx context.Context,
	data_uint64_id DataUint64_Id_Field) (
	data_uint64 *DataUint64, err error) {
	__id_val := data_uint64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uint64s ( id ) VALUES ( ? ) RETURNING data_uint64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint64 = &DataUint64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint64, nil

}

func (obj *sqlite3Impl) Create_DataUtimestamp(ctx context.Context,
	data_utimestamp_id DataUtimestamp_Id_Field) (
	data_utimestamp *DataUtimestamp, err error) {
	__id_val := data_utimestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_utimestamps ( id ) VALUES ( ? ) RETURNING data_utimestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_utimestamp = &DataUtimestamp{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_utimestamp.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_utimestamp, nil

}

func (obj *sqlite3Impl) Paged_DataBlob(ctx context.Context,
	limit int, start *Paged_DataBlob_Continuation) (
	rows []*DataBlob, next *Paged_DataBlob_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs WHERE (data_blobs.id) > ? ORDER BY data_blobs.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs ORDER BY data_blobs.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataBlob_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_blob := &DataBlob{}
		err = __rows.Scan(&data_blob.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_blob)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataDate(ctx context.Context,
	limit int, start *Paged_DataDate_Continuation) (
	rows []*DataDate, next *Paged_DataDate_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates WHERE (data_dates.id) > ? ORDER BY data_dates.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates ORDER BY data_dates.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataDate_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_date := &DataDate{}
		err = __rows.Scan(&data_date.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_date)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataFloat(ctx context.Context,
	limit int, start *Paged_DataFloat_Continuation) (
	rows []*DataFloat, next *Paged_DataFloat_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats WHERE (data_floats.id) > ? ORDER BY data_floats.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats ORDER BY data_floats.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float := &DataFloat{}
		err = __rows.Scan(&data_float.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataFloat64(ctx context.Context,
	limit int, start *Paged_DataFloat64_Continuation) (
	rows []*DataFloat64, next *Paged_DataFloat64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s WHERE (data_float64s.id) > ? ORDER BY data_float64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s ORDER BY data_float64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float64 := &DataFloat64{}
		err = __rows.Scan(&data_float64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataInt(ctx context.Context,
	limit int, start *Paged_DataInt_Continuation) (
	rows []*DataInt, next *Paged_DataInt_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints WHERE (data_ints.id) > ? ORDER BY data_ints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints ORDER BY data_ints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int := &DataInt{}
		err = __rows.Scan(&data_int.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataInt64(ctx context.Context,
	limit int, start *Paged_DataInt64_Continuation) (
	rows []*DataInt64, next *Paged_DataInt64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s WHERE (data_int64s.id) > ? ORDER BY data_int64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s ORDER BY data_int64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int64 := &DataInt64{}
		err = __rows.Scan(&data_int64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataJson(ctx context.Context,
	limit int, start *Paged_DataJson_Continuation) (
	rows []*DataJson, next *Paged_DataJson_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons WHERE (data_jsons.id) > ? ORDER BY data_jsons.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons ORDER BY data_jsons.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataJson_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_json := &DataJson{}
		err = __rows.Scan(&data_json.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_json)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataSerial(ctx context.Context,
	limit int, start *Paged_DataSerial_Continuation) (
	rows []*DataSerial, next *Paged_DataSerial_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials WHERE (data_serials.id) > ? ORDER BY data_serials.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials ORDER BY data_serials.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial := &DataSerial{}
		err = __rows.Scan(&data_serial.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataSerial64(ctx context.Context,
	limit int, start *Paged_DataSerial64_Continuation) (
	rows []*DataSerial64, next *Paged_DataSerial64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s WHERE (data_serial64s.id) > ? ORDER BY data_serial64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s ORDER BY data_serial64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial64 := &DataSerial64{}
		err = __rows.Scan(&data_serial64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataText(ctx context.Context,
	limit int, start *Paged_DataText_Continuation) (
	rows []*DataText, next *Paged_DataText_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts WHERE (data_texts.id) > ? ORDER BY data_texts.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts ORDER BY data_texts.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataText_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_text := &DataText{}
		err = __rows.Scan(&data_text.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_text)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataTimestamp(ctx context.Context,
	limit int, start *Paged_DataTimestamp_Continuation) (
	rows []*DataTimestamp, next *Paged_DataTimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps WHERE (data_timestamps.id) > ? ORDER BY data_timestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps ORDER BY data_timestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataTimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_timestamp := &DataTimestamp{}
		err = __rows.Scan(&data_timestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_timestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataUint(ctx context.Context,
	limit int, start *Paged_DataUint_Continuation) (
	rows []*DataUint, next *Paged_DataUint_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints WHERE (data_uints.id) > ? ORDER BY data_uints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints ORDER BY data_uints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint := &DataUint{}
		err = __rows.Scan(&data_uint.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataUint64(ctx context.Context,
	limit int, start *Paged_DataUint64_Continuation) (
	rows []*DataUint64, next *Paged_DataUint64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s WHERE (data_uint64s.id) > ? ORDER BY data_uint64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s ORDER BY data_uint64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint64 := &DataUint64{}
		err = __rows.Scan(&data_uint64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *sqlite3Impl) Paged_DataUtimestamp(ctx context.Context,
	limit int, start *Paged_DataUtimestamp_Continuation) (
	rows []*DataUtimestamp, next *Paged_DataUtimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps WHERE (data_utimestamps.id) > ? ORDER BY data_utimestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps ORDER BY data_utimestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUtimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_utimestamp := &DataUtimestamp{}
		err = __rows.Scan(&data_utimestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_utimestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_utimestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uint64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_texts;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serial64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_jsons;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_int64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_ints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_float64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_floats;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_dates;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_blobs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *pgxImpl) Create_DataBlob(ctx context.Context,
	data_blob_id DataBlob_Id_Field) (
	data_blob *DataBlob, err error) {
	__id_val := data_blob_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_blobs ( id ) VALUES ( ? ) RETURNING data_blobs.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_blob = &DataBlob{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_blob.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_blob, nil

}

func (obj *pgxImpl) Create_DataDate(ctx context.Context,
	data_date_id DataDate_Id_Field) (
	data_date *DataDate, err error) {
	__id_val := data_date_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_dates ( id ) VALUES ( ? ) RETURNING data_dates.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_date = &DataDate{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_date.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_date, nil

}

func (obj *pgxImpl) Create_DataFloat(ctx context.Context,
	data_float_id DataFloat_Id_Field) (
	data_float *DataFloat, err error) {
	__id_val := data_float_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_floats ( id ) VALUES ( ? ) RETURNING data_floats.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float = &DataFloat{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float, nil

}

func (obj *pgxImpl) Create_DataFloat64(ctx context.Context,
	data_float64_id DataFloat64_Id_Field) (
	data_float64 *DataFloat64, err error) {
	__id_val := data_float64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_float64s ( id ) VALUES ( ? ) RETURNING data_float64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float64 = &DataFloat64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float64, nil

}

func (obj *pgxImpl) Create_DataInt(ctx context.Context,
	data_int_id DataInt_Id_Field) (
	data_int *DataInt, err error) {
	__id_val := data_int_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_ints ( id ) VALUES ( ? ) RETURNING data_ints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int = &DataInt{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int, nil

}

func (obj *pgxImpl) Create_DataInt64(ctx context.Context,
	data_int64_id DataInt64_Id_Field) (
	data_int64 *DataInt64, err error) {
	__id_val := data_int64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_int64s ( id ) VALUES ( ? ) RETURNING data_int64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int64 = &DataInt64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int64, nil

}

func (obj *pgxImpl) Create_DataJson(ctx context.Context,
	data_json_id DataJson_Id_Field) (
	data_json *DataJson, err error) {
	__id_val := data_json_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_jsons ( id ) VALUES ( ? ) RETURNING data_jsons.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_json = &DataJson{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_json.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_json, nil

}

func (obj *pgxImpl) Create_DataSerial(ctx context.Context) (
	data_serial *DataSerial, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serials DEFAULT VALUES RETURNING data_serials.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial = &DataSerial{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial, nil

}

func (obj *pgxImpl) Create_DataSerial64(ctx context.Context) (
	data_serial64 *DataSerial64, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serial64s DEFAULT VALUES RETURNING data_serial64s.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial64 = &DataSerial64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial64, nil

}

func (obj *pgxImpl) Create_DataText(ctx context.Context,
	data_text_id DataText_Id_Field) (
	data_text *DataText, err error) {
	__id_val := data_text_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_texts ( id ) VALUES ( ? ) RETURNING data_texts.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_text = &DataText{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_text.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_text, nil

}

func (obj *pgxImpl) Create_DataTimestamp(ctx context.Context,
	data_timestamp_id DataTimestamp_Id_Field) (
	data_timestamp *DataTimestamp, err error) {
	__id_val := data_timestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_timestamps ( id ) VALUES ( ? ) RETURNING data_timestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_timestamp = &DataTimestamp{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_timestamp.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_timestamp, nil

}

func (obj *pgxImpl) Create_DataUint(ctx context.Context,
	data_uint_id DataUint_Id_Field) (
	data_uint *DataUint, err error) {
	__id_val := data_uint_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uints ( id ) VALUES ( ? ) RETURNING data_uints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint = &DataUint{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint, nil

}

func (obj *pgxImpl) Create_DataUint64(ctx context.Context,
	data_uint64_id DataUint64_Id_Field) (
	data_uint64 *DataUint64, err error) {
	__id_val := data_uint64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uint64s ( id ) VALUES ( ? ) RETURNING data_uint64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint64 = &DataUint64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint64, nil

}

func (obj *pgxImpl) Create_DataUtimestamp(ctx context.Context,
	data_utimestamp_id DataUtimestamp_Id_Field) (
	data_utimestamp *DataUtimestamp, err error) {
	__id_val := data_utimestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_utimestamps ( id ) VALUES ( ? ) RETURNING data_utimestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_utimestamp = &DataUtimestamp{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_utimestamp.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_utimestamp, nil

}

func (obj *pgxImpl) Paged_DataBlob(ctx context.Context,
	limit int, start *Paged_DataBlob_Continuation) (
	rows []*DataBlob, next *Paged_DataBlob_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs WHERE (data_blobs.id) > ? ORDER BY data_blobs.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs ORDER BY data_blobs.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataBlob_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_blob := &DataBlob{}
		err = __rows.Scan(&data_blob.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_blob)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataDate(ctx context.Context,
	limit int, start *Paged_DataDate_Continuation) (
	rows []*DataDate, next *Paged_DataDate_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates WHERE (data_dates.id) > ? ORDER BY data_dates.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates ORDER BY data_dates.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataDate_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_date := &DataDate{}
		err = __rows.Scan(&data_date.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_date)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataFloat(ctx context.Context,
	limit int, start *Paged_DataFloat_Continuation) (
	rows []*DataFloat, next *Paged_DataFloat_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats WHERE (data_floats.id) > ? ORDER BY data_floats.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats ORDER BY data_floats.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float := &DataFloat{}
		err = __rows.Scan(&data_float.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataFloat64(ctx context.Context,
	limit int, start *Paged_DataFloat64_Continuation) (
	rows []*DataFloat64, next *Paged_DataFloat64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s WHERE (data_float64s.id) > ? ORDER BY data_float64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s ORDER BY data_float64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float64 := &DataFloat64{}
		err = __rows.Scan(&data_float64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataInt(ctx context.Context,
	limit int, start *Paged_DataInt_Continuation) (
	rows []*DataInt, next *Paged_DataInt_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints WHERE (data_ints.id) > ? ORDER BY data_ints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints ORDER BY data_ints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int := &DataInt{}
		err = __rows.Scan(&data_int.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataInt64(ctx context.Context,
	limit int, start *Paged_DataInt64_Continuation) (
	rows []*DataInt64, next *Paged_DataInt64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s WHERE (data_int64s.id) > ? ORDER BY data_int64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s ORDER BY data_int64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int64 := &DataInt64{}
		err = __rows.Scan(&data_int64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataJson(ctx context.Context,
	limit int, start *Paged_DataJson_Continuation) (
	rows []*DataJson, next *Paged_DataJson_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons WHERE (data_jsons.id) > ? ORDER BY data_jsons.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons ORDER BY data_jsons.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataJson_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_json := &DataJson{}
		err = __rows.Scan(&data_json.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_json)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataSerial(ctx context.Context,
	limit int, start *Paged_DataSerial_Continuation) (
	rows []*DataSerial, next *Paged_DataSerial_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials WHERE (data_serials.id) > ? ORDER BY data_serials.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials ORDER BY data_serials.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial := &DataSerial{}
		err = __rows.Scan(&data_serial.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataSerial64(ctx context.Context,
	limit int, start *Paged_DataSerial64_Continuation) (
	rows []*DataSerial64, next *Paged_DataSerial64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s WHERE (data_serial64s.id) > ? ORDER BY data_serial64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s ORDER BY data_serial64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial64 := &DataSerial64{}
		err = __rows.Scan(&data_serial64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataText(ctx context.Context,
	limit int, start *Paged_DataText_Continuation) (
	rows []*DataText, next *Paged_DataText_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts WHERE (data_texts.id) > ? ORDER BY data_texts.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts ORDER BY data_texts.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataText_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_text := &DataText{}
		err = __rows.Scan(&data_text.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_text)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataTimestamp(ctx context.Context,
	limit int, start *Paged_DataTimestamp_Continuation) (
	rows []*DataTimestamp, next *Paged_DataTimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps WHERE (data_timestamps.id) > ? ORDER BY data_timestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps ORDER BY data_timestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataTimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_timestamp := &DataTimestamp{}
		err = __rows.Scan(&data_timestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_timestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataUint(ctx context.Context,
	limit int, start *Paged_DataUint_Continuation) (
	rows []*DataUint, next *Paged_DataUint_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints WHERE (data_uints.id) > ? ORDER BY data_uints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints ORDER BY data_uints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint := &DataUint{}
		err = __rows.Scan(&data_uint.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataUint64(ctx context.Context,
	limit int, start *Paged_DataUint64_Continuation) (
	rows []*DataUint64, next *Paged_DataUint64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s WHERE (data_uint64s.id) > ? ORDER BY data_uint64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s ORDER BY data_uint64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint64 := &DataUint64{}
		err = __rows.Scan(&data_uint64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxImpl) Paged_DataUtimestamp(ctx context.Context,
	limit int, start *Paged_DataUtimestamp_Continuation) (
	rows []*DataUtimestamp, next *Paged_DataUtimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps WHERE (data_utimestamps.id) > ? ORDER BY data_utimestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps ORDER BY data_utimestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUtimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_utimestamp := &DataUtimestamp{}
		err = __rows.Scan(&data_utimestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_utimestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (impl pgxImpl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(*pgconn.PgError); ok {
		if e.Code[:2] == "23" {
			return e.ConstraintName, true
		}
	}
	return "", false
}

func (obj *pgxImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_utimestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uint64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_texts;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serial64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_jsons;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_int64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_ints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_float64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_floats;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_dates;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_blobs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *pgxcockroachImpl) Create_DataBlob(ctx context.Context,
	data_blob_id DataBlob_Id_Field) (
	data_blob *DataBlob, err error) {
	__id_val := data_blob_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_blobs ( id ) VALUES ( ? ) RETURNING data_blobs.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_blob = &DataBlob{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_blob.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_blob, nil

}

func (obj *pgxcockroachImpl) Create_DataDate(ctx context.Context,
	data_date_id DataDate_Id_Field) (
	data_date *DataDate, err error) {
	__id_val := data_date_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_dates ( id ) VALUES ( ? ) RETURNING data_dates.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_date = &DataDate{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_date.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_date, nil

}

func (obj *pgxcockroachImpl) Create_DataFloat(ctx context.Context,
	data_float_id DataFloat_Id_Field) (
	data_float *DataFloat, err error) {
	__id_val := data_float_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_floats ( id ) VALUES ( ? ) RETURNING data_floats.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float = &DataFloat{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float, nil

}

func (obj *pgxcockroachImpl) Create_DataFloat64(ctx context.Context,
	data_float64_id DataFloat64_Id_Field) (
	data_float64 *DataFloat64, err error) {
	__id_val := data_float64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_float64s ( id ) VALUES ( ? ) RETURNING data_float64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float64 = &DataFloat64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float64, nil

}

func (obj *pgxcockroachImpl) Create_DataInt(ctx context.Context,
	data_int_id DataInt_Id_Field) (
	data_int *DataInt, err error) {
	__id_val := data_int_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_ints ( id ) VALUES ( ? ) RETURNING data_ints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int = &DataInt{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int, nil

}

func (obj *pgxcockroachImpl) Create_DataInt64(ctx context.Context,
	data_int64_id DataInt64_Id_Field) (
	data_int64 *DataInt64, err error) {
	__id_val := data_int64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_int64s ( id ) VALUES ( ? ) RETURNING data_int64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int64 = &DataInt64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int64, nil

}

func (obj *pgxcockroachImpl) Create_DataJson(ctx context.Context,
	data_json_id DataJson_Id_Field) (
	data_json *DataJson, err error) {
	__id_val := data_json_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_jsons ( id ) VALUES ( ? ) RETURNING data_jsons.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_json = &DataJson{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_json.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_json, nil

}

func (obj *pgxcockroachImpl) Create_DataSerial(ctx context.Context) (
	data_serial *DataSerial, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serials DEFAULT VALUES RETURNING data_serials.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial = &DataSerial{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial, nil

}

func (obj *pgxcockroachImpl) Create_DataSerial64(ctx context.Context) (
	data_serial64 *DataSerial64, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serial64s DEFAULT VALUES RETURNING data_serial64s.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial64 = &DataSerial64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial64, nil

}

func (obj *pgxcockroachImpl) Create_DataText(ctx context.Context,
	data_text_id DataText_Id_Field) (
	data_text *DataText, err error) {
	__id_val := data_text_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_texts ( id ) VALUES ( ? ) RETURNING data_texts.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_text = &DataText{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_text.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_text, nil

}

func (obj *pgxcockroachImpl) Create_DataTimestamp(ctx context.Context,
	data_timestamp_id DataTimestamp_Id_Field) (
	data_timestamp *DataTimestamp, err error) {
	__id_val := data_timestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_timestamps ( id ) VALUES ( ? ) RETURNING data_timestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_timestamp = &DataTimestamp{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_timestamp.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_timestamp, nil

}

func (obj *pgxcockroachImpl) Create_DataUint(ctx context.Context,
	data_uint_id DataUint_Id_Field) (
	data_uint *DataUint, err error) {
	__id_val := data_uint_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uints ( id ) VALUES ( ? ) RETURNING data_uints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint = &DataUint{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint, nil

}

func (obj *pgxcockroachImpl) Create_DataUint64(ctx context.Context,
	data_uint64_id DataUint64_Id_Field) (
	data_uint64 *DataUint64, err error) {
	__id_val := data_uint64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uint64s ( id ) VALUES ( ? ) RETURNING data_uint64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint64 = &DataUint64{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint64.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint64, nil

}

func (obj *pgxcockroachImpl) Create_DataUtimestamp(ctx context.Context,
	data_utimestamp_id DataUtimestamp_Id_Field) (
	data_utimestamp *DataUtimestamp, err error) {
	__id_val := data_utimestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_utimestamps ( id ) VALUES ( ? ) RETURNING data_utimestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_utimestamp = &DataUtimestamp{}
	err = obj.driver.QueryRowContext(ctx, __stmt, __values...).Scan(&data_utimestamp.Id)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_utimestamp, nil

}

func (obj *pgxcockroachImpl) Paged_DataBlob(ctx context.Context,
	limit int, start *Paged_DataBlob_Continuation) (
	rows []*DataBlob, next *Paged_DataBlob_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs WHERE (data_blobs.id) > ? ORDER BY data_blobs.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs ORDER BY data_blobs.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataBlob_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_blob := &DataBlob{}
		err = __rows.Scan(&data_blob.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_blob)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataDate(ctx context.Context,
	limit int, start *Paged_DataDate_Continuation) (
	rows []*DataDate, next *Paged_DataDate_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates WHERE (data_dates.id) > ? ORDER BY data_dates.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates ORDER BY data_dates.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataDate_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_date := &DataDate{}
		err = __rows.Scan(&data_date.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_date)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataFloat(ctx context.Context,
	limit int, start *Paged_DataFloat_Continuation) (
	rows []*DataFloat, next *Paged_DataFloat_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats WHERE (data_floats.id) > ? ORDER BY data_floats.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats ORDER BY data_floats.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float := &DataFloat{}
		err = __rows.Scan(&data_float.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataFloat64(ctx context.Context,
	limit int, start *Paged_DataFloat64_Continuation) (
	rows []*DataFloat64, next *Paged_DataFloat64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s WHERE (data_float64s.id) > ? ORDER BY data_float64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s ORDER BY data_float64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float64 := &DataFloat64{}
		err = __rows.Scan(&data_float64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataInt(ctx context.Context,
	limit int, start *Paged_DataInt_Continuation) (
	rows []*DataInt, next *Paged_DataInt_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints WHERE (data_ints.id) > ? ORDER BY data_ints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints ORDER BY data_ints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int := &DataInt{}
		err = __rows.Scan(&data_int.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataInt64(ctx context.Context,
	limit int, start *Paged_DataInt64_Continuation) (
	rows []*DataInt64, next *Paged_DataInt64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s WHERE (data_int64s.id) > ? ORDER BY data_int64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s ORDER BY data_int64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int64 := &DataInt64{}
		err = __rows.Scan(&data_int64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataJson(ctx context.Context,
	limit int, start *Paged_DataJson_Continuation) (
	rows []*DataJson, next *Paged_DataJson_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons WHERE (data_jsons.id) > ? ORDER BY data_jsons.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons ORDER BY data_jsons.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataJson_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_json := &DataJson{}
		err = __rows.Scan(&data_json.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_json)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataSerial(ctx context.Context,
	limit int, start *Paged_DataSerial_Continuation) (
	rows []*DataSerial, next *Paged_DataSerial_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials WHERE (data_serials.id) > ? ORDER BY data_serials.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials ORDER BY data_serials.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial := &DataSerial{}
		err = __rows.Scan(&data_serial.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataSerial64(ctx context.Context,
	limit int, start *Paged_DataSerial64_Continuation) (
	rows []*DataSerial64, next *Paged_DataSerial64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s WHERE (data_serial64s.id) > ? ORDER BY data_serial64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s ORDER BY data_serial64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial64 := &DataSerial64{}
		err = __rows.Scan(&data_serial64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataText(ctx context.Context,
	limit int, start *Paged_DataText_Continuation) (
	rows []*DataText, next *Paged_DataText_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts WHERE (data_texts.id) > ? ORDER BY data_texts.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts ORDER BY data_texts.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataText_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_text := &DataText{}
		err = __rows.Scan(&data_text.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_text)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataTimestamp(ctx context.Context,
	limit int, start *Paged_DataTimestamp_Continuation) (
	rows []*DataTimestamp, next *Paged_DataTimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps WHERE (data_timestamps.id) > ? ORDER BY data_timestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps ORDER BY data_timestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataTimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_timestamp := &DataTimestamp{}
		err = __rows.Scan(&data_timestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_timestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataUint(ctx context.Context,
	limit int, start *Paged_DataUint_Continuation) (
	rows []*DataUint, next *Paged_DataUint_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints WHERE (data_uints.id) > ? ORDER BY data_uints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints ORDER BY data_uints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint := &DataUint{}
		err = __rows.Scan(&data_uint.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataUint64(ctx context.Context,
	limit int, start *Paged_DataUint64_Continuation) (
	rows []*DataUint64, next *Paged_DataUint64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s WHERE (data_uint64s.id) > ? ORDER BY data_uint64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s ORDER BY data_uint64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint64 := &DataUint64{}
		err = __rows.Scan(&data_uint64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *pgxcockroachImpl) Paged_DataUtimestamp(ctx context.Context,
	limit int, start *Paged_DataUtimestamp_Continuation) (
	rows []*DataUtimestamp, next *Paged_DataUtimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps WHERE (data_utimestamps.id) > ? ORDER BY data_utimestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps ORDER BY data_utimestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {
		__values = append(__values, start._value_id, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUtimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_utimestamp := &DataUtimestamp{}
		err = __rows.Scan(&data_utimestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_utimestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (impl pgxcockroachImpl) isConstraintError(err error) (constraint string, ok bool) {
	if e, ok := err.(*pgconn.PgError); ok {
		if e.Code[:2] == "23" {
			return e.ConstraintName, true
		}
	}
	return "", false
}

func (obj *pgxcockroachImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_utimestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uint64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_texts;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serial64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_jsons;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_int64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_ints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_float64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_floats;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_dates;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_blobs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *spannerImpl) Create_DataBlob(ctx context.Context,
	data_blob_id DataBlob_Id_Field) (
	data_blob *DataBlob, err error) {
	__id_val := data_blob_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_blobs ( id ) VALUES ( ? ) THEN RETURN data_blobs.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_blob = &DataBlob{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_blob.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_blob, nil

}

func (obj *spannerImpl) Create_DataDate(ctx context.Context,
	data_date_id DataDate_Id_Field) (
	data_date *DataDate, err error) {
	__id_val := data_date_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_dates ( id ) VALUES ( ? ) THEN RETURN data_dates.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_date = &DataDate{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_date.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_date, nil

}

func (obj *spannerImpl) Create_DataFloat(ctx context.Context,
	data_float_id DataFloat_Id_Field) (
	data_float *DataFloat, err error) {
	__id_val := data_float_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_floats ( id ) VALUES ( ? ) THEN RETURN data_floats.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float = &DataFloat{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float, nil

}

func (obj *spannerImpl) Create_DataFloat64(ctx context.Context,
	data_float64_id DataFloat64_Id_Field) (
	data_float64 *DataFloat64, err error) {
	__id_val := data_float64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_float64s ( id ) VALUES ( ? ) THEN RETURN data_float64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_float64 = &DataFloat64{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_float64.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_float64, nil

}

func (obj *spannerImpl) Create_DataInt(ctx context.Context,
	data_int_id DataInt_Id_Field) (
	data_int *DataInt, err error) {
	__id_val := data_int_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_ints ( id ) VALUES ( ? ) THEN RETURN data_ints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int = &DataInt{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int, nil

}

func (obj *spannerImpl) Create_DataInt64(ctx context.Context,
	data_int64_id DataInt64_Id_Field) (
	data_int64 *DataInt64, err error) {
	__id_val := data_int64_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_int64s ( id ) VALUES ( ? ) THEN RETURN data_int64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_int64 = &DataInt64{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_int64.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_int64, nil

}

func (obj *spannerImpl) Create_DataJson(ctx context.Context,
	data_json_id DataJson_Id_Field) (
	data_json *DataJson, err error) {
	__id_val := data_json_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_jsons ( id ) VALUES ( ? ) THEN RETURN data_jsons.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_json = &DataJson{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_json.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_json, nil

}

func (obj *spannerImpl) Create_DataSerial(ctx context.Context) (
	data_serial *DataSerial, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serials ( id ) VALUES ( DEFAULT ) THEN RETURN data_serials.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial = &DataSerial{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial, nil

}

func (obj *spannerImpl) Create_DataSerial64(ctx context.Context) (
	data_serial64 *DataSerial64, err error) {

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_serial64s ( id ) VALUES ( DEFAULT ) THEN RETURN data_serial64s.id")

	var __values []any

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_serial64 = &DataSerial64{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_serial64.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_serial64, nil

}

func (obj *spannerImpl) Create_DataText(ctx context.Context,
	data_text_id DataText_Id_Field) (
	data_text *DataText, err error) {
	__id_val := data_text_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_texts ( id ) VALUES ( ? ) THEN RETURN data_texts.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_text = &DataText{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_text.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_text, nil

}

func (obj *spannerImpl) Create_DataTimestamp(ctx context.Context,
	data_timestamp_id DataTimestamp_Id_Field) (
	data_timestamp *DataTimestamp, err error) {
	__id_val := data_timestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_timestamps ( id ) VALUES ( ? ) THEN RETURN data_timestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_timestamp = &DataTimestamp{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_timestamp.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_timestamp, nil

}

func (obj *spannerImpl) Create_DataUint(ctx context.Context,
	data_uint_id DataUint_Id_Field) (
	data_uint *DataUint, err error) {
	__id_val := data_uint_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uints ( id ) VALUES ( ? ) THEN RETURN data_uints.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint = &DataUint{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint, nil

}

func (obj *spannerImpl) Create_DataUint64(ctx context.Context,
	data_uint64_id DataUint64_Id_Field) (
	data_uint64 *DataUint64, err error) {
	__id_val := spannerConvertArgument(data_uint64_id.value())

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_uint64s ( id ) VALUES ( ? ) THEN RETURN data_uint64s.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_uint64 = &DataUint64{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_uint64.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_uint64, nil

}

func (obj *spannerImpl) Create_DataUtimestamp(ctx context.Context,
	data_utimestamp_id DataUtimestamp_Id_Field) (
	data_utimestamp *DataUtimestamp, err error) {
	__id_val := data_utimestamp_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO data_utimestamps ( id ) VALUES ( ? ) THEN RETURN data_utimestamps.id")

	var __values []any
	__values = append(__values, __id_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	data_utimestamp = &DataUtimestamp{}
	d := obj.driver
	var tx *sql.Tx
	if !obj.txn {
		tx, err = obj.db.DB.BeginTx(ctx, nil)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		d = tx
		defer func() {
			if txErr := tx.Rollback(); txErr != nil && !errors.Is(sql.ErrTxDone, txErr) {
				err = obj.makeErr(errors.Join(err, txErr))
			}
		}()
	}
	err = d.QueryRowContext(ctx, __stmt, __values...).Scan(&data_utimestamp.Id)
	if !obj.txn {
		if err == nil {
			err = obj.makeErr(tx.Commit())
		}
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return data_utimestamp, nil

}

func (obj *spannerImpl) Paged_DataBlob(ctx context.Context,
	limit int, start *Paged_DataBlob_Continuation) (
	rows []*DataBlob, next *Paged_DataBlob_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs WHERE (data_blobs.id) > ? ORDER BY data_blobs.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_blobs.id, data_blobs.id FROM data_blobs ORDER BY data_blobs.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataBlob_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_blob := &DataBlob{}
		err = __rows.Scan(&data_blob.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_blob)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataDate(ctx context.Context,
	limit int, start *Paged_DataDate_Continuation) (
	rows []*DataDate, next *Paged_DataDate_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates WHERE (data_dates.id) > ? ORDER BY data_dates.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_dates.id, data_dates.id FROM data_dates ORDER BY data_dates.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataDate_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_date := &DataDate{}
		err = __rows.Scan(&data_date.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_date)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataFloat(ctx context.Context,
	limit int, start *Paged_DataFloat_Continuation) (
	rows []*DataFloat, next *Paged_DataFloat_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats WHERE (data_floats.id) > ? ORDER BY data_floats.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_floats.id, data_floats.id FROM data_floats ORDER BY data_floats.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float := &DataFloat{}
		err = __rows.Scan(&data_float.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataFloat64(ctx context.Context,
	limit int, start *Paged_DataFloat64_Continuation) (
	rows []*DataFloat64, next *Paged_DataFloat64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s WHERE (data_float64s.id) > ? ORDER BY data_float64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_float64s.id, data_float64s.id FROM data_float64s ORDER BY data_float64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataFloat64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_float64 := &DataFloat64{}
		err = __rows.Scan(&data_float64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_float64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataInt(ctx context.Context,
	limit int, start *Paged_DataInt_Continuation) (
	rows []*DataInt, next *Paged_DataInt_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints WHERE (data_ints.id) > ? ORDER BY data_ints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_ints.id, data_ints.id FROM data_ints ORDER BY data_ints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int := &DataInt{}
		err = __rows.Scan(&data_int.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataInt64(ctx context.Context,
	limit int, start *Paged_DataInt64_Continuation) (
	rows []*DataInt64, next *Paged_DataInt64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s WHERE (data_int64s.id) > ? ORDER BY data_int64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_int64s.id, data_int64s.id FROM data_int64s ORDER BY data_int64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataInt64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_int64 := &DataInt64{}
		err = __rows.Scan(&data_int64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_int64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataJson(ctx context.Context,
	limit int, start *Paged_DataJson_Continuation) (
	rows []*DataJson, next *Paged_DataJson_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons WHERE (data_jsons.id) > ? ORDER BY data_jsons.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_jsons.id, data_jsons.id FROM data_jsons ORDER BY data_jsons.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataJson_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_json := &DataJson{}
		err = __rows.Scan(&data_json.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_json)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataSerial(ctx context.Context,
	limit int, start *Paged_DataSerial_Continuation) (
	rows []*DataSerial, next *Paged_DataSerial_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials WHERE (data_serials.id) > ? ORDER BY data_serials.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serials.id, data_serials.id FROM data_serials ORDER BY data_serials.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial := &DataSerial{}
		err = __rows.Scan(&data_serial.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataSerial64(ctx context.Context,
	limit int, start *Paged_DataSerial64_Continuation) (
	rows []*DataSerial64, next *Paged_DataSerial64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s WHERE (data_serial64s.id) > ? ORDER BY data_serial64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_serial64s.id, data_serial64s.id FROM data_serial64s ORDER BY data_serial64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataSerial64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_serial64 := &DataSerial64{}
		err = __rows.Scan(&data_serial64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_serial64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataText(ctx context.Context,
	limit int, start *Paged_DataText_Continuation) (
	rows []*DataText, next *Paged_DataText_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts WHERE (data_texts.id) > ? ORDER BY data_texts.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_texts.id, data_texts.id FROM data_texts ORDER BY data_texts.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataText_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_text := &DataText{}
		err = __rows.Scan(&data_text.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_text)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataTimestamp(ctx context.Context,
	limit int, start *Paged_DataTimestamp_Continuation) (
	rows []*DataTimestamp, next *Paged_DataTimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps WHERE (data_timestamps.id) > ? ORDER BY data_timestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_timestamps.id, data_timestamps.id FROM data_timestamps ORDER BY data_timestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataTimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_timestamp := &DataTimestamp{}
		err = __rows.Scan(&data_timestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_timestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataUint(ctx context.Context,
	limit int, start *Paged_DataUint_Continuation) (
	rows []*DataUint, next *Paged_DataUint_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints WHERE (data_uints.id) > ? ORDER BY data_uints.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uints.id, data_uints.id FROM data_uints ORDER BY data_uints.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint := &DataUint{}
		err = __rows.Scan(&data_uint.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataUint64(ctx context.Context,
	limit int, start *Paged_DataUint64_Continuation) (
	rows []*DataUint64, next *Paged_DataUint64_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s WHERE (data_uint64s.id) > ? ORDER BY data_uint64s.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_uint64s.id, data_uint64s.id FROM data_uint64s ORDER BY data_uint64s.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUint64_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_uint64 := &DataUint64{}
		err = __rows.Scan(&data_uint64.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_uint64)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (obj *spannerImpl) Paged_DataUtimestamp(ctx context.Context,
	limit int, start *Paged_DataUtimestamp_Continuation) (
	rows []*DataUtimestamp, next *Paged_DataUtimestamp_Continuation, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps WHERE (data_utimestamps.id) > ? ORDER BY data_utimestamps.id LIMIT ?")

	var __embed_first_stmt = __sqlbundle_Literal("SELECT data_utimestamps.id, data_utimestamps.id FROM data_utimestamps ORDER BY data_utimestamps.id LIMIT ?")

	var __values []any

	var __stmt string
	if start != nil && start._set {

		__values = append(__values, start._value_id)

		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	} else {
		__values = append(__values, limit)
		__stmt = __sqlbundle_Render(obj.dialect, __embed_first_stmt)
	}
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
	if err != nil {
		return nil, nil, obj.makeErr(err)
	}
	defer __rows.Close()

	var __continuation Paged_DataUtimestamp_Continuation
	__continuation._set = true

	for __rows.Next() {
		data_utimestamp := &DataUtimestamp{}
		err = __rows.Scan(&data_utimestamp.Id, &__continuation._value_id)
		if err != nil {
			return nil, nil, obj.makeErr(err)
		}
		rows = append(rows, data_utimestamp)
		next = &__continuation
	}
	if err := __rows.Err(); err != nil {
		return nil, nil, obj.makeErr(err)
	}

	return rows, next, nil

}

func (impl spannerImpl) isConstraintError(err error) (constraint string, ok bool) {
	return "", false
}

func (obj *spannerImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_utimestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uint64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_uints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_texts;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serial64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_jsons;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_int64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_ints;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_float64s;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_floats;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_dates;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM data_blobs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Methods interface {
	Create_DataBlob(ctx context.Context,
		data_blob_id DataBlob_Id_Field) (
		data_blob *DataBlob, err error)

	Create_DataDate(ctx context.Context,
		data_date_id DataDate_Id_Field) (
		data_date *DataDate, err error)

	Create_DataFloat(ctx context.Context,
		data_float_id DataFloat_Id_Field) (
		data_float *DataFloat, err error)

	Create_DataFloat64(ctx context.Context,
		data_float64_id DataFloat64_Id_Field) (
		data_float64 *DataFloat64, err error)

	Create_DataInt(ctx context.Context,
		data_int_id DataInt_Id_Field) (
		data_int *DataInt, err error)

	Create_DataInt64(ctx context.Context,
		data_int64_id DataInt64_Id_Field) (
		data_int64 *DataInt64, err error)

	Create_DataJson(ctx context.Context,
		data_json_id DataJson_Id_Field) (
		data_json *DataJson, err error)

	Create_DataSerial(ctx context.Context) (
		data_serial *DataSerial, err error)

	Create_DataSerial64(ctx context.Context) (
		data_serial64 *DataSerial64, err error)

	Create_DataText(ctx context.Context,
		data_text_id DataText_Id_Field) (
		data_text *DataText, err error)

	Create_DataTimestamp(ctx context.Context,
		data_timestamp_id DataTimestamp_Id_Field) (
		data_timestamp *DataTimestamp, err error)

	Create_DataUint(ctx context.Context,
		data_uint_id DataUint_Id_Field) (
		data_uint *DataUint, err error)

	Create_DataUint64(ctx context.Context,
		data_uint64_id DataUint64_Id_Field) (
		data_uint64 *DataUint64, err error)

	Create_DataUtimestamp(ctx context.Context,
		data_utimestamp_id DataUtimestamp_Id_Field) (
		data_utimestamp *DataUtimestamp, err error)

	Paged_DataBlob(ctx context.Context,
		limit int, start *Paged_DataBlob_Continuation) (
		rows []*DataBlob, next *Paged_DataBlob_Continuation, err error)

	Paged_DataDate(ctx context.Context,
		limit int, start *Paged_DataDate_Continuation) (
		rows []*DataDate, next *Paged_DataDate_Continuation, err error)

	Paged_DataFloat(ctx context.Context,
		limit int, start *Paged_DataFloat_Continuation) (
		rows []*DataFloat, next *Paged_DataFloat_Continuation, err error)

	Paged_DataFloat64(ctx context.Context,
		limit int, start *Paged_DataFloat64_Continuation) (
		rows []*DataFloat64, next *Paged_DataFloat64_Continuation, err error)

	Paged_DataInt(ctx context.Context,
		limit int, start *Paged_DataInt_Continuation) (
		rows []*DataInt, next *Paged_DataInt_Continuation, err error)

	Paged_DataInt64(ctx context.Context,
		limit int, start *Paged_DataInt64_Continuation) (
		rows []*DataInt64, next *Paged_DataInt64_Continuation, err error)

	Paged_DataJson(ctx context.Context,
		limit int, start *Paged_DataJson_Continuation) (
		rows []*DataJson, next *Paged_DataJson_Continuation, err error)

	Paged_DataSerial(ctx context.Context,
		limit int, start *Paged_DataSerial_Continuation) (
		rows []*DataSerial, next *Paged_DataSerial_Continuation, err error)

	Paged_DataSerial64(ctx context.Context,
		limit int, start *Paged_DataSerial64_Continuation) (
		rows []*DataSerial64, next *Paged_DataSerial64_Continuation, err error)

	Paged_DataText(ctx context.Context,
		limit int, start *Paged_DataText_Continuation) (
		rows []*DataText, next *Paged_DataText_Continuation, err error)

	Paged_DataTimestamp(ctx context.Context,
		limit int, start *Paged_DataTimestamp_Continuation) (
		rows []*DataTimestamp, next *Paged_DataTimestamp_Continuation, err error)

	Paged_DataUint(ctx context.Context,
		limit int, start *Paged_DataUint_Continuation) (
		rows []*DataUint, next *Paged_DataUint_Continuation, err error)

	Paged_DataUint64(ctx context.Context,
		limit int, start *Paged_DataUint64_Continuation) (
		rows []*DataUint64, next *Paged_DataUint64_Continuation, err error)

	Paged_DataUtimestamp(ctx context.Context,
		limit int, start *Paged_DataUtimestamp_Continuation) (
		rows []*DataUtimestamp, next *Paged_DataUtimestamp_Continuation, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() []string
	DropSchema() []string

	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

var sqlite3DriverName = func() string {
	var id [16]byte
	_, _ = rand.Read(id[:])
	return fmt.Sprintf("sqlite3_%x", string(id[:]))
}()

func init() {
	sql.Register(sqlite3DriverName, &sqlite3.SQLiteDriver{
		ConnectHook: sqlite3SetupConn,
	})
}

// SQLite3JournalMode controls the journal_mode pragma for all new connections.
// Since it is read without a mutex, it must be changed to the value you want
// before any Open calls.
var SQLite3JournalMode = "WAL"

func sqlite3SetupConn(conn *sqlite3.SQLiteConn) (err error) {
	_, err = conn.Exec("PRAGMA foreign_keys = ON", nil)
	if err != nil {
		return makeErr(err)
	}
	_, err = conn.Exec("PRAGMA journal_mode = "+SQLite3JournalMode, nil)
	if err != nil {
		return makeErr(err)
	}
	return nil
}

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open(sqlite3DriverName, source)
}

func openpgx(source string) (*sql.DB, error) {
	return sql.Open("pgx", source)
}

func openpgxcockroach(source string) (*sql.DB, error) {
	// try first with "cockroach" as a driver in case someone has registered
	// some special stuff. if that fails, then try again with "pgx" as
	// the driver.
	db, err := sql.Open("cockroach", source)
	if err != nil {
		db, err = sql.Open("pgx", source)
	}
	return db, err
}

func openspanner(source string) (*sql.DB, error) {
	return sql.Open("spanner", strings.TrimPrefix(source, "spanner://"))
}

func spannerConvertArgument(v any) any {
	switch v := v.(type) {
	case uint64:
		return spannerUint64{val: v}
	case *uint64:
		return spannerPointerUint64{val: v}
	default:
		return v
	}
}

type spannerUint64 struct {
	val uint64
}

func (s spannerUint64) Value() (sqldriver.Value, error) {
	if s.val > math.MaxInt64 {
		return nil, fmt.Errorf("value %d is larger than max supported INT64 column value %d", s.val, math.MaxInt64)
	}
	return int64(s.val), nil
}

type spannerPointerUint64 struct {
	val *uint64
}

func (s spannerPointerUint64) Value() (sqldriver.Value, error) {
	if s.val == nil {
		return nil, nil
	}
	if *s.val > math.MaxInt64 {
		return nil, fmt.Errorf("value %d is larger than max supported INT64 column value %d", *s.val, math.MaxInt64)
	}
	return int64(*s.val), nil
}
